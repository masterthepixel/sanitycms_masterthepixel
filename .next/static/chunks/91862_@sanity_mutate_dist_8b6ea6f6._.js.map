{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/projects/masterthepixel/node_modules/.pnpm/@sanity+mutate@0.11.0-canary.4_xstate@5.25.0/node_modules/@sanity/mutate/dist/_chunks-es/parse.js","sources":["file:///home/sysadmin/projects/masterthepixel/node_modules/.pnpm/%40sanity%2Bmutate%400.11.0-canary.4_xstate%405.25.0/node_modules/%40sanity/mutate/src/path/parser/parse.ts"],"sourcesContent":["import {type PathElement} from '../types'\nimport {type StringToPath} from './types'\n\nexport function parse<const T extends string>(path: T): StringToPath<T> {\n  return path\n    .split(/[[.\\]]/g)\n    .filter(Boolean)\n    .map(seg => (seg.includes('==') ? parseSegment(seg) : coerce(seg))) as any\n}\n\nconst IS_NUMERIC = /^-?\\d+$/\n\nfunction unquote(str: string) {\n  return str.replace(/^['\"]/, '').replace(/['\"]$/, '')\n}\n\nfunction parseSegment(segment: string): PathElement {\n  const [key, value] = segment.split('==')\n  if (key !== '_key') {\n    throw new Error(\n      `Currently only \"_key\" is supported as path segment. Found ${key}`,\n    )\n  }\n  if (typeof value === 'undefined') {\n    throw new Error('Invalid path segment, expected `key==\"value\"`')\n  }\n  return {_key: unquote(value)}\n}\n\nfunction coerce(segment: string): PathElement {\n  return IS_NUMERIC.test(segment) ? Number(segment) : segment\n}\n"],"names":[],"mappings":";;;;AAGO,SAAS,MAA8B,IAAA,EAA0B;IACtE,OAAO,KACJ,KAAA,CAAM,SAAS,EACf,MAAA,CAAO,OAAO,EACd,GAAA,CAAI,CAAA,MAAQ,IAAI,QAAA,CAAS,IAAI,IAAI,aAAa,GAAG,IAAI,OAAO,GAAG,CAAE;AACtE;AAEA,MAAM,aAAa;AAEnB,SAAS,QAAQ,GAAA,EAAa;IAC5B,OAAO,IAAI,OAAA,CAAQ,SAAS,EAAE,EAAE,OAAA,CAAQ,SAAS,EAAE;AACrD;AAEA,SAAS,aAAa,OAAA,EAA8B;IAClD,MAAM,CAAC,KAAK,KAAK,CAAA,GAAI,QAAQ,KAAA,CAAM,IAAI;IACvC,IAAI,QAAQ,QACV,MAAM,IAAI,MACR,6DAAgE,OAAH,GAAG;IAGpE,IAAI,OAAO,QAAU,KACb,MAAA,IAAI,MAAM,+CAA+C;IAEjE,OAAO;QAAC,MAAM,QAAQ,KAAK;IAAC;AAC9B;AAEA,SAAS,OAAO,OAAA,EAA8B;IAC5C,OAAO,WAAW,IAAA,CAAK,OAAO,IAAI,OAAO,OAAO,IAAI;AACtD","debugId":null}},
    {"offset": {"line": 32, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/projects/masterthepixel/node_modules/.pnpm/@sanity+mutate@0.11.0-canary.4_xstate@5.25.0/node_modules/@sanity/mutate/dist/_chunks-es/stringify.js","sources":["file:///home/sysadmin/projects/masterthepixel/node_modules/.pnpm/%40sanity%2Bmutate%400.11.0-canary.4_xstate%405.25.0/node_modules/%40sanity/mutate/src/path/utils/predicates.ts","file:///home/sysadmin/projects/masterthepixel/node_modules/.pnpm/%40sanity%2Bmutate%400.11.0-canary.4_xstate%405.25.0/node_modules/%40sanity/mutate/src/path/parser/stringify.ts"],"sourcesContent":["import {type KeyedPathElement, type Path, type PathElement} from '../types'\n\nfunction safeGetElementAt<T>(array: T[] | readonly T[], index: number): T {\n  if (index < 0 || index >= array.length) {\n    throw new Error('Index out of bounds')\n  }\n  return array[index]!\n}\n\nexport function startsWith(parentPath: Path, path: Path): boolean {\n  return (\n    parentPath.length <= path.length &&\n    parentPath.every((segment, i) =>\n      isElementEqual(segment, safeGetElementAt(path, i)),\n    )\n  )\n}\n\nexport function isEqual(path: Path, otherPath: Path): boolean {\n  return (\n    path.length === otherPath.length &&\n    path.every((segment, i) =>\n      isElementEqual(segment, safeGetElementAt(path, i)),\n    )\n  )\n}\n\nexport function isElementEqual(\n  segmentA: PathElement,\n  segmentB: PathElement,\n): boolean {\n  if (isKeyElement(segmentA) && isKeyElement(segmentB)) {\n    return segmentA._key === segmentB._key\n  }\n\n  if (isIndexElement(segmentA)) {\n    return Number(segmentA) === Number(segmentB)\n  }\n\n  return segmentA === segmentB\n}\n\nexport function isKeyElement(\n  segment: PathElement,\n): segment is KeyedPathElement {\n  return typeof (segment as any)?._key === 'string'\n}\nexport function isIndexElement(segment: PathElement): segment is number {\n  return typeof segment === 'number'\n}\n\nexport function isKeyedElement(\n  element: PathElement,\n): element is KeyedPathElement {\n  return (\n    typeof element === 'object' &&\n    '_key' in element &&\n    typeof element._key === 'string'\n  )\n}\nexport function isArrayElement(\n  element: PathElement,\n): element is KeyedPathElement | number {\n  return typeof element === 'number' || isKeyedElement(element)\n}\n\nexport function isPropertyElement(element: PathElement): element is string {\n  return typeof element === 'string'\n}\n","import {type Path, type PathElement} from '../types'\nimport {isKeyedElement} from '../utils/predicates'\n\nconst IS_DOTTABLE = /^[a-z_$]+/\n\nfunction stringifySegment(segment: PathElement, hasLeading: boolean): string {\n  if (Array.isArray(segment)) {\n    return `[${segment[0]}:${segment[1] || ''}]`\n  }\n  const type = typeof segment\n\n  const isNumber = type === 'number'\n\n  if (isNumber) {\n    return `[${segment}]`\n  }\n\n  if (isKeyedElement(segment)) {\n    return `[_key==${JSON.stringify(segment._key)}]`\n  }\n\n  if (typeof segment === 'string' && IS_DOTTABLE.test(segment)) {\n    return hasLeading ? segment : `.${segment}`\n  }\n\n  return `['${segment}']`\n}\n\nexport function stringify(pathArray: Path): string {\n  return pathArray\n    .map((segment, i) => stringifySegment(segment, i === 0))\n    .join('')\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;AAEA,SAAS,iBAAoB,KAAA,EAA2B,KAAA,EAAkB;IACpE,IAAA,QAAQ,KAAK,SAAS,MAAM,MAAA,EACxB,MAAA,IAAI,MAAM,qBAAqB;IAEvC,OAAO,KAAA,CAAM,KAAK,CAAA;AACpB;AAEgB,SAAA,WAAW,UAAA,EAAkB,IAAA,EAAqB;IAChE,OACE,WAAW,MAAA,IAAU,KAAK,MAAA,IAC1B,WAAW,KAAA,CAAM,CAAC,SAAS,IACzB,eAAe,SAAS,iBAAiB,MAAM,CAAC,CAAC;AAGvD;AAEgB,SAAA,QAAQ,IAAA,EAAY,SAAA,EAA0B;IAC5D,OACE,KAAK,MAAA,KAAW,UAAU,MAAA,IAC1B,KAAK,KAAA,CAAM,CAAC,SAAS,IACnB,eAAe,SAAS,iBAAiB,MAAM,CAAC,CAAC;AAGvD;AAEgB,SAAA,eACd,QAAA,EACA,QAAA,EACS;IACT,OAAI,aAAa,QAAQ,KAAK,aAAa,QAAQ,IAC1C,SAAS,IAAA,KAAS,SAAS,IAAA,GAGhC,eAAe,QAAQ,IAClB,OAAO,QAAQ,MAAM,OAAO,QAAQ,IAGtC,aAAa;AACtB;AAEO,SAAS,aACd,OAAA,EAC6B;IACtB,OAAA,0DAAQ,QAAiB,IAAA,KAAS;AAC3C;AACO,SAAS,eAAe,OAAA,EAAyC;IACtE,OAAO,OAAO,WAAY;AAC5B;AAEO,SAAS,eACd,OAAA,EAC6B;IAC7B,OACE,OAAO,WAAY,YACnB,UAAU,WACV,OAAO,QAAQ,IAAA,IAAS;AAE5B;AACO,SAAS,eACd,OAAA,EACsC;IACtC,OAAO,OAAO,WAAY,YAAY,eAAe,OAAO;AAC9D;AAEO,SAAS,kBAAkB,OAAA,EAAyC;IACzE,OAAO,OAAO,WAAY;AAC5B;ACjEA,MAAM,cAAc;AAEpB,SAAS,iBAAiB,OAAA,EAAsB,UAAA,EAA6B;IAC3E,OAAI,MAAM,OAAA,CAAQ,OAAO,IAChB,WAAI,OAAA,CAAQ,CAAC,CAAC,EAAA,KAAoB,OAAhB,OAAA,CAAQ,CAAC,CAAA,IAAK,EAAE,EAAA,OAE9B,OAAO,WAEM,WAGjB,IAAW,OAAP,OAAO,EAAA,OAGhB,eAAe,OAAO,IACjB,UAAsC,OAA5B,KAAK,SAAA,CAAU,QAAQ,IAAI,CAAC,EAAA,OAG3C,OAAO,WAAY,YAAY,YAAY,IAAA,CAAK,OAAO,IAClD,aAAa,UAAU,IAAW,OAAP,OAAO,IAGpC,KAAY,OAAP,OAAO,EAAA;AACrB;AAEO,SAAS,UAAU,SAAA,EAAyB;IACjD,OAAO,UACJ,GAAA,CAAI,CAAC,SAAS,IAAM,iBAAiB,SAAS,MAAM,CAAC,CAAC,EACtD,IAAA,CAAK,EAAE;AACZ","debugId":null}},
    {"offset": {"line": 93, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/projects/masterthepixel/node_modules/.pnpm/@sanity+mutate@0.11.0-canary.4_xstate@5.25.0/node_modules/@sanity/mutate/dist/_chunks-es/decode.js","sources":["file:///home/sysadmin/projects/masterthepixel/node_modules/.pnpm/%40sanity%2Bmutate%400.11.0-canary.4_xstate%405.25.0/node_modules/%40sanity/mutate/src/encoders/sanity/decode.ts"],"sourcesContent":["import {type SetIfMissingOp, type SetOp} from '../../mutations/operations/types'\nimport {\n  type Mutation,\n  type NodePatch,\n  type SanityDocumentBase,\n} from '../../mutations/types'\nimport {parse as parsePath} from '../../path/parser/parse'\n\nexport type {Mutation, SanityDocumentBase}\n\nexport type SanityDiffMatchPatch = {\n  id: string\n  diffMatchPatch: {[path: string]: string}\n}\n\nexport type SanitySetPatch = {\n  id: string\n  set: {[path: string]: any}\n}\n\nexport type Insert = {\n  before?: string\n  after?: string\n  replace?: string\n  items: any[]\n}\n\nexport type SanityInsertPatch = {\n  id: string\n  insert: Insert\n}\n\nexport type SanityUnsetPatch = {\n  id: string\n  unset: string[]\n}\n\nexport type SanityIncPatch = {\n  id: string\n  inc: {[path: string]: number}\n}\n\nexport type SanityDecPatch = {\n  id: string\n  dec: {[path: string]: number}\n}\n\nexport type SanitySetIfMissingPatch = {\n  id: string\n  setIfMissing: {[path: string]: any}\n}\n\nexport type SanityPatch =\n  | SanitySetPatch\n  | SanityUnsetPatch\n  | SanityInsertPatch\n  | SanitySetIfMissingPatch\n  | SanityDiffMatchPatch\n  | SanityIncPatch\n  | SanityDecPatch\n\nexport type SanityCreateIfNotExistsMutation<Doc extends SanityDocumentBase> = {\n  createIfNotExists: Doc\n}\n\nexport type SanityCreateOrReplaceMutation<Doc extends SanityDocumentBase> = {\n  createOrReplace: Doc\n}\n\nexport type SanityCreateMutation<Doc extends SanityDocumentBase> = {\n  create: Doc\n}\n\nexport type SanityDeleteMutation = {\n  delete: {id: string}\n}\n\nexport type SanityPatchMutation = {\n  patch:\n    | SanitySetPatch\n    | SanitySetIfMissingPatch\n    | SanityDiffMatchPatch\n    | SanityInsertPatch\n    | SanityUnsetPatch\n}\n\nexport type SanityMutation<\n  Doc extends SanityDocumentBase = SanityDocumentBase,\n> =\n  | SanityCreateMutation<Doc>\n  | SanityCreateIfNotExistsMutation<Doc>\n  | SanityCreateOrReplaceMutation<Doc>\n  | SanityDeleteMutation\n  | SanityPatchMutation\n\nfunction isCreateIfNotExistsMutation<Doc extends SanityDocumentBase>(\n  sanityMutation: SanityMutation<Doc>,\n): sanityMutation is SanityCreateIfNotExistsMutation<Doc> {\n  return 'createIfNotExists' in sanityMutation\n}\n\nfunction isCreateOrReplaceMutation<Doc extends SanityDocumentBase>(\n  sanityMutation: SanityMutation<Doc>,\n): sanityMutation is SanityCreateOrReplaceMutation<Doc> {\n  return 'createOrReplace' in sanityMutation\n}\n\nfunction isCreateMutation<Doc extends SanityDocumentBase>(\n  sanityMutation: SanityMutation<Doc>,\n): sanityMutation is SanityCreateMutation<Doc> {\n  return 'create' in sanityMutation\n}\n\nfunction isDeleteMutation(\n  sanityMutation: SanityMutation<any>,\n): sanityMutation is SanityDeleteMutation {\n  return 'delete' in sanityMutation\n}\n\nfunction isPatchMutation(\n  sanityMutation: SanityMutation<any>,\n): sanityMutation is SanityPatchMutation {\n  return 'patch' in sanityMutation\n}\n\nfunction isSetPatch(sanityPatch: SanityPatch): sanityPatch is SanitySetPatch {\n  return 'set' in sanityPatch\n}\n\nfunction isSetIfMissingPatch(\n  sanityPatch: SanityPatch,\n): sanityPatch is SanitySetIfMissingPatch {\n  return 'setIfMissing' in sanityPatch\n}\n\nfunction isDiffMatchPatch(\n  sanityPatch: SanityPatch,\n): sanityPatch is SanityDiffMatchPatch {\n  return 'diffMatchPatch' in sanityPatch\n}\n\nfunction isUnsetPatch(\n  sanityPatch: SanityPatch,\n): sanityPatch is SanityUnsetPatch {\n  return 'unset' in sanityPatch\n}\n\nfunction isIncPatch(sanityPatch: SanityPatch): sanityPatch is SanityIncPatch {\n  return 'inc' in sanityPatch\n}\n\nfunction isDecPatch(sanityPatch: SanityPatch): sanityPatch is SanityDecPatch {\n  return 'inc' in sanityPatch\n}\n\nfunction isInsertPatch(\n  sanityPatch: SanityPatch,\n): sanityPatch is SanityInsertPatch {\n  return 'insert' in sanityPatch\n}\n\nexport function decodeAll<Doc extends SanityDocumentBase>(\n  sanityMutations: SanityMutation<Doc>[],\n) {\n  return sanityMutations.map(decodeMutation)\n}\n\nexport function decode<Doc extends SanityDocumentBase>(\n  encodedMutation: SanityMutation<Doc>,\n) {\n  return decodeMutation(encodedMutation)\n}\n\nfunction decodeMutation<Doc extends SanityDocumentBase>(\n  encodedMutation: SanityMutation<Doc>,\n): Mutation {\n  if (isCreateIfNotExistsMutation(encodedMutation)) {\n    return {\n      type: 'createIfNotExists',\n      document: encodedMutation.createIfNotExists,\n    }\n  }\n  if (isCreateOrReplaceMutation(encodedMutation)) {\n    return {\n      type: 'createOrReplace',\n      document: encodedMutation.createOrReplace,\n    }\n  }\n  if (isCreateMutation(encodedMutation)) {\n    return {type: 'create', document: encodedMutation.create}\n  }\n  if (isDeleteMutation(encodedMutation)) {\n    return {id: encodedMutation.delete.id, type: 'delete'}\n  }\n  if (isPatchMutation(encodedMutation)) {\n    return {\n      type: 'patch',\n      id: encodedMutation.patch.id,\n      patches: decodeNodePatches(encodedMutation.patch),\n    }\n  }\n  throw new Error(`Unknown mutation: ${JSON.stringify(encodedMutation)}`)\n}\n\nconst POSITION_KEYS = ['before', 'replace', 'after'] as const\n\nfunction getInsertPosition(insert: Insert) {\n  const positions = POSITION_KEYS.filter(k => k in insert)\n  if (positions.length > 1) {\n    throw new Error(\n      `Insert patch is ambiguous. Should only contain one of: ${POSITION_KEYS.join(\n        ', ',\n      )}, instead found ${positions.join(', ')}`,\n    )\n  }\n  return positions[0]\n}\n\nfunction decodeNodePatches<T>(patch: SanityPatch): NodePatch<any, any>[] {\n  // If multiple patches are included, then the order of execution is as follows\n  // set, setIfMissing, unset, inc, dec, insert.\n  // order is defined here: https://www.sanity.io/docs/http-mutations#2f480b2baca5\n  return [\n    ...getSetPatches(patch),\n    ...getSetIfMissingPatches(patch),\n    ...getUnsetPatches(patch),\n    ...getIncPatches(patch),\n    ...getDecPatches(patch),\n    ...getInsertPatches(patch),\n  ]\n\n  throw new Error(`Unknown patch: ${JSON.stringify(patch)}`)\n}\n\nfunction getSetPatches(patch: SanityPatch): NodePatch<any[], SetOp<any>>[] {\n  return isSetPatch(patch)\n    ? Object.keys(patch.set).map(path => ({\n        path: parsePath(path),\n        op: {type: 'set', value: patch.set[path]},\n      }))\n    : []\n}\n\nfunction getSetIfMissingPatches(\n  patch: SanityPatch,\n): NodePatch<any[], SetIfMissingOp<any>>[] {\n  return isSetIfMissingPatch(patch)\n    ? Object.keys(patch.setIfMissing).map(path => ({\n        path: parsePath(path),\n        op: {type: 'setIfMissing', value: patch.setIfMissing[path]},\n      }))\n    : []\n}\n\nfunction getDiffMatchPatchPatches(patch: SanityPatch) {\n  return isDiffMatchPatch(patch)\n    ? Object.keys(patch.diffMatchPatch).map(path => ({\n        path: parsePath(path),\n        op: {type: 'diffMatchPatch', value: patch.diffMatchPatch[path]},\n      }))\n    : []\n}\n\nfunction getUnsetPatches(patch: SanityPatch) {\n  return isUnsetPatch(patch)\n    ? patch.unset.map(path => ({\n        path: parsePath(path),\n        op: {type: 'unset'},\n      }))\n    : []\n}\n\nfunction getIncPatches(patch: SanityPatch) {\n  return isIncPatch(patch)\n    ? Object.keys(patch.inc).map(path => ({\n        path: parsePath(path),\n        op: {type: 'inc', amount: patch.inc[path]},\n      }))\n    : []\n}\n\nfunction getDecPatches(patch: SanityPatch) {\n  return isDecPatch(patch)\n    ? Object.keys(patch.dec).map(path => ({\n        path: parsePath(path),\n        op: {type: 'dec', amount: patch.dec[path]},\n      }))\n    : []\n}\n\nfunction getInsertPatches(patch: SanityPatch) {\n  if (!isInsertPatch(patch)) {\n    return []\n  }\n  const position = getInsertPosition(patch.insert)\n  if (!position) {\n    throw new Error('Insert patch missing position')\n  }\n\n  const path = parsePath(patch.insert[position]!)\n  const referenceItem = path.pop()\n\n  const op =\n    position === 'replace'\n      ? {\n          type: 'insert',\n          position: position,\n          referenceItem,\n          items: patch.insert.items,\n        }\n      : {\n          type: 'insert',\n          position: position,\n          referenceItem,\n          items: patch.insert.items,\n        }\n\n  return [{path, op}]\n}\n"],"names":["parsePath"],"mappings":"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","debugId":null}},
    {"offset": {"line": 256, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/projects/masterthepixel/node_modules/.pnpm/@sanity+mutate@0.11.0-canary.4_xstate@5.25.0/node_modules/@sanity/mutate/dist/_chunks-es/encode.js","sources":["file:///home/sysadmin/projects/masterthepixel/node_modules/.pnpm/%40sanity%2Bmutate%400.11.0-canary.4_xstate%405.25.0/node_modules/%40sanity/mutate/src/encoders/sanity/encode.ts"],"sourcesContent":["import {\n  type Mutation,\n  type NodePatch,\n  type Transaction,\n} from '../../mutations/types'\nimport {stringify as stringifyPath} from '../../path/parser/stringify'\n\nexport function encode(mutation: Mutation) {\n  return encodeMutation(mutation)\n}\n\nexport function encodeAll(mutations: Mutation[]) {\n  return mutations.flatMap(encode)\n}\n\nexport function encodeTransaction(transaction: Transaction) {\n  return {\n    transactionId: transaction.id,\n    mutations: encodeAll(transaction.mutations),\n  }\n}\n\nexport function encodeMutation(mutation: Mutation) {\n  if (\n    mutation.type === 'create' ||\n    mutation.type === 'createIfNotExists' ||\n    mutation.type === 'createOrReplace'\n  ) {\n    return {[mutation.type]: mutation.document}\n  }\n  if (mutation.type === 'delete') {\n    return {\n      delete: {id: mutation.id},\n    }\n  }\n  const ifRevisionID = mutation.options?.ifRevision\n  return mutation.patches.map(patch => {\n    return {\n      patch: {\n        id: mutation.id,\n        ...(ifRevisionID && {ifRevisionID}),\n        ...patchToSanity(patch),\n      },\n    }\n  })\n}\n\nfunction patchToSanity(patch: NodePatch) {\n  const {path, op} = patch\n  if (op.type === 'unset') {\n    return {unset: [stringifyPath(path)]}\n  }\n  if (op.type === 'insert') {\n    return {\n      insert: {\n        [op.position]: stringifyPath([...path, op.referenceItem]),\n        items: op.items,\n      },\n    }\n  }\n  if (op.type === 'diffMatchPatch') {\n    return {diffMatchPatch: {[stringifyPath(path)]: op.value}}\n  }\n  if (op.type === 'inc') {\n    return {inc: {[stringifyPath(path)]: op.amount}}\n  }\n  if (op.type === 'dec') {\n    return {dec: {[stringifyPath(path)]: op.amount}}\n  }\n  if (op.type === 'set' || op.type === 'setIfMissing') {\n    return {[op.type]: {[stringifyPath(path)]: op.value}}\n  }\n  if (op.type === 'truncate') {\n    const range = [\n      op.startIndex,\n      typeof op.endIndex === 'number' ? op.endIndex : '',\n    ].join(':')\n\n    return {unset: [`${stringifyPath(path)}[${range}]`]}\n  }\n  if (op.type === 'upsert') {\n    // note: upsert currently not supported by sanity, so will always insert at reference position\n    return {\n      unset: op.items.map(item =>\n        stringifyPath([...path, {_key: (item as any)._key}]),\n      ),\n      insert: {\n        [op.position]: stringifyPath([...path, op.referenceItem]),\n        items: op.items,\n      },\n    }\n  }\n  if (op.type === 'assign') {\n    return {\n      set: Object.fromEntries(\n        Object.keys(op.value).map(key => [\n          stringifyPath(path.concat(key)),\n          op.value[key as keyof typeof op.value],\n        ]),\n      ),\n    }\n  }\n  if (op.type === 'unassign') {\n    return {\n      unset: op.keys.map(key => stringifyPath(path.concat(key))),\n    }\n  }\n  if (op.type === 'replace') {\n    return {\n      insert: {\n        replace: stringifyPath(path.concat(op.referenceItem)),\n        items: op.items,\n      },\n    }\n  }\n  if (op.type === 'remove') {\n    return {\n      unset: [stringifyPath(path.concat(op.referenceItem))],\n    }\n  }\n  //@ts-expect-error all cases should be covered\n  throw new Error(`Unknown operation type ${op.type}`)\n}\n"],"names":["stringifyPath"],"mappings":"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","debugId":null}},
    {"offset": {"line": 391, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/projects/masterthepixel/node_modules/.pnpm/@sanity+mutate@0.11.0-canary.4_xstate@5.25.0/node_modules/@sanity/mutate/dist/_chunks-es/isObject.js","sources":["file:///home/sysadmin/projects/masterthepixel/node_modules/.pnpm/%40sanity%2Bmutate%400.11.0-canary.4_xstate%405.25.0/node_modules/%40sanity/mutate/src/utils/isObject.ts"],"sourcesContent":["export function isObject(val: unknown): val is {\n  [K in string]: unknown\n} {\n  return val !== null && typeof val === 'object' && !Array.isArray(val)\n}\n"],"names":[],"mappings":";;;;AAAO,SAAS,SAAS,GAAA,EAEvB;IACO,OAAA,QAAQ,QAAQ,OAAO,OAAQ,YAAY,CAAC,MAAM,OAAA,CAAQ,GAAG;AACtE","debugId":null}},
    {"offset": {"line": 404, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/projects/masterthepixel/node_modules/.pnpm/@sanity+mutate@0.11.0-canary.4_xstate@5.25.0/node_modules/@sanity/mutate/dist/_chunks-es/arrify.js","sources":["file:///home/sysadmin/projects/masterthepixel/node_modules/.pnpm/%40sanity%2Bmutate%400.11.0-canary.4_xstate%405.25.0/node_modules/%40sanity/mutate/src/utils/arrify.ts"],"sourcesContent":["export type Arrify<T> = (T extends (infer E)[] ? E : T)[]\n\nexport function arrify<T>(val: T): Arrify<T> {\n  return Array.isArray(val) ? val : ([val] as any)\n}\n"],"names":[],"mappings":";;;;AAEO,SAAS,OAAU,GAAA,EAAmB;IAC3C,OAAO,MAAM,OAAA,CAAQ,GAAG,IAAI,MAAO;QAAC,GAAG;KAAA;AACzC","debugId":null}},
    {"offset": {"line": 419, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/projects/masterthepixel/node_modules/.pnpm/@sanity+mutate@0.11.0-canary.4_xstate@5.25.0/node_modules/@sanity/mutate/dist/index.js","sources":["file:///home/sysadmin/projects/masterthepixel/node_modules/.pnpm/%40sanity%2Bmutate%400.11.0-canary.4_xstate%405.25.0/node_modules/%40sanity/mutate/src/encoders/compact/decode.ts","file:///home/sysadmin/projects/masterthepixel/node_modules/.pnpm/%40sanity%2Bmutate%400.11.0-canary.4_xstate%405.25.0/node_modules/%40sanity/mutate/src/encoders/compact/encode.ts","file:///home/sysadmin/projects/masterthepixel/node_modules/.pnpm/%40sanity%2Bmutate%400.11.0-canary.4_xstate%405.25.0/node_modules/%40sanity/mutate/src/formatters/compact.ts","file:///home/sysadmin/projects/masterthepixel/node_modules/.pnpm/%40sanity%2Bmutate%400.11.0-canary.4_xstate%405.25.0/node_modules/%40sanity/mutate/src/mutations/operations/creators.ts","file:///home/sysadmin/projects/masterthepixel/node_modules/.pnpm/%40sanity%2Bmutate%400.11.0-canary.4_xstate%405.25.0/node_modules/%40sanity/mutate/src/mutations/autoKeys.ts","file:///home/sysadmin/projects/masterthepixel/node_modules/.pnpm/%40sanity%2Bmutate%400.11.0-canary.4_xstate%405.25.0/node_modules/%40sanity/mutate/src/mutations/creators.ts"],"sourcesContent":["import {\n  type Mutation,\n  type PatchMutation,\n  type SanityDocumentBase,\n} from '../../mutations/types'\nimport {type Index, type KeyedPathElement} from '../../path'\nimport {parse as parsePath} from '../../path/parser/parse'\nimport {\n  type CompactMutation,\n  type CompactPatchMutation,\n  type CreateIfNotExistsMutation,\n  type CreateMutation,\n  type CreateOrReplaceMutation,\n  type DeleteMutation,\n  type ItemRef,\n} from './types'\n\nexport {Mutation, SanityDocumentBase}\n\nexport function decode<Doc extends SanityDocumentBase>(\n  mutations: CompactMutation<Doc>[],\n): Mutation[] {\n  return mutations.map(decodeMutation)\n}\n\nexport function decodeMutation<Doc extends SanityDocumentBase>(\n  mutation: CompactMutation<Doc>,\n): Mutation {\n  const [type] = mutation\n  if (type === 'delete') {\n    const [, id] = mutation as DeleteMutation\n    return {id, type}\n  } else if (type === 'create') {\n    const [, document] = mutation as CreateMutation<Doc>\n    return {type, document}\n  } else if (type === 'createIfNotExists') {\n    const [, document] = mutation as CreateIfNotExistsMutation<Doc>\n    return {type, document}\n  } else if (type === 'createOrReplace') {\n    const [, document] = mutation as CreateOrReplaceMutation<Doc>\n    return {type, document}\n  } else if (type === 'patch') {\n    return decodePatchMutation(mutation)\n  }\n  throw new Error(`Unrecognized mutation: ${JSON.stringify(mutation)}`)\n}\n\nfunction decodePatchMutation(mutation: CompactPatchMutation): PatchMutation {\n  const [, type, id, serializedPath, , revisionId] = mutation\n\n  const path = parsePath(serializedPath)\n  if (type === 'dec' || type === 'inc') {\n    const [, , , , [amount]] = mutation\n    return {\n      type: 'patch',\n      id,\n      patches: [{path, op: {type: 'inc', amount}}],\n      ...createOpts(revisionId),\n    }\n  }\n  if (type === 'unset') {\n    return {\n      type: 'patch',\n      id,\n      patches: [{path, op: {type: 'unset'}}],\n      ...createOpts(revisionId),\n    }\n  }\n  if (type === 'insert') {\n    const [, , , , [position, ref, items]] = mutation\n    return {\n      type: 'patch',\n      id,\n      patches: [\n        {\n          path,\n          op: {\n            type: 'insert',\n            position,\n            items,\n            referenceItem: typeof ref === 'string' ? {_key: ref} : ref,\n          },\n        },\n      ],\n      ...createOpts(revisionId),\n    }\n  }\n  if (type === 'set') {\n    const [, , , , [value]] = mutation\n    return {\n      type: 'patch',\n      id,\n      patches: [{path, op: {type: 'set', value}}],\n      ...createOpts(revisionId),\n    }\n  }\n  if (type === 'setIfMissing') {\n    const [, , , , [value]] = mutation\n    return {\n      type: 'patch',\n      id,\n      patches: [{path, op: {type: 'setIfMissing', value}}],\n      ...createOpts(revisionId),\n    }\n  }\n  if (type === 'diffMatchPatch') {\n    const [, , , , [value]] = mutation\n    return {\n      type: 'patch',\n      id,\n      patches: [{path, op: {type: 'diffMatchPatch', value}}],\n      ...createOpts(revisionId),\n    }\n  }\n  if (type === 'truncate') {\n    const [, , , , [startIndex, endIndex]] = mutation\n\n    return {\n      type: 'patch',\n      id,\n      patches: [{path, op: {type: 'truncate', startIndex, endIndex}}],\n      ...createOpts(revisionId),\n    }\n  }\n  if (type === 'assign') {\n    const [, , , , [value]] = mutation\n    return {\n      type: 'patch',\n      id,\n      patches: [{path, op: {type: 'assign', value}}],\n      ...createOpts(revisionId),\n    }\n  }\n  if (type === 'replace') {\n    const [, , , , [ref, items]] = mutation\n    return {\n      type: 'patch',\n      id,\n      patches: [\n        {path, op: {type: 'replace', items, referenceItem: decodeItemRef(ref)}},\n      ],\n      ...createOpts(revisionId),\n    }\n  }\n  if (type === 'upsert') {\n    const [, , , , [position, referenceItem, items]] = mutation\n    return {\n      type: 'patch',\n      id,\n      patches: [\n        {\n          path,\n          op: {\n            type: 'upsert',\n            items,\n            referenceItem: decodeItemRef(referenceItem),\n            position,\n          },\n        },\n      ],\n      ...createOpts(revisionId),\n    }\n  }\n  throw new Error(`Invalid mutation type: ${type}`)\n}\n\nfunction decodeItemRef(ref: ItemRef): Index | KeyedPathElement {\n  return typeof ref === 'string' ? {_key: ref} : ref\n}\n\nfunction createOpts(revisionId: undefined | string) {\n  return revisionId ? {options: {ifRevision: revisionId}} : null\n}\n","// An example of a compact transport/serialization format\nimport {\n  type Mutation,\n  type NodePatch,\n  type SanityDocumentBase,\n} from '../../mutations/types'\nimport {type Index, type KeyedPathElement} from '../../path'\nimport {stringify as stringifyPath} from '../../path/parser/stringify'\nimport {\n  type CompactMutation,\n  type CompactPatchMutation,\n  type ItemRef,\n} from './types'\n\nexport function encode<Doc extends SanityDocumentBase>(\n  mutations: Mutation[],\n): CompactMutation<Doc>[] {\n  return mutations.flatMap(m => encodeMutation<Doc>(m))\n}\n\nfunction encodeItemRef(ref: Index | KeyedPathElement): ItemRef {\n  return typeof ref === 'number' ? ref : ref._key\n}\n\nfunction encodeMutation<Doc extends SanityDocumentBase>(\n  mutation: Mutation,\n): CompactMutation<Doc>[] {\n  if (\n    mutation.type === 'create' ||\n    mutation.type === 'createIfNotExists' ||\n    mutation.type === 'createOrReplace'\n  ) {\n    return [[mutation.type, mutation.document]]\n  }\n  if (mutation.type === 'delete') {\n    return [['delete', mutation.id]]\n  }\n  if (mutation.type === 'patch') {\n    return mutation.patches.map(patch =>\n      maybeAddRevision(\n        mutation.options?.ifRevision,\n        encodePatchMutation(mutation.id, patch),\n      ),\n    )\n  }\n\n  //@ts-expect-error - all cases are covered\n  throw new Error(`Invalid mutation type: ${mutation.type}`)\n}\n\nfunction encodePatchMutation(\n  id: string,\n  patch: NodePatch<any>,\n): CompactPatchMutation {\n  const {op} = patch\n  const path = stringifyPath(patch.path)\n  if (op.type === 'unset') {\n    return ['patch', 'unset', id, path, []]\n  }\n  if (op.type === 'diffMatchPatch') {\n    return ['patch', 'diffMatchPatch', id, path, [op.value]]\n  }\n  if (op.type === 'inc' || op.type === 'dec') {\n    return ['patch', op.type, id, path, [op.amount]]\n  }\n  if (op.type === 'set') {\n    return ['patch', op.type, id, path, [op.value]]\n  }\n  if (op.type === 'setIfMissing') {\n    return ['patch', op.type, id, path, [op.value]]\n  }\n  if (op.type === 'insert') {\n    return [\n      'patch',\n      'insert',\n      id,\n      path,\n      [op.position, encodeItemRef(op.referenceItem), op.items],\n    ]\n  }\n  if (op.type === 'upsert') {\n    return [\n      'patch',\n      'upsert',\n      id,\n      path,\n      [op.position, encodeItemRef(op.referenceItem), op.items],\n    ]\n  }\n  if (op.type === 'assign') {\n    return ['patch', 'assign', id, path, [op.value]]\n  }\n  if (op.type === 'unassign') {\n    return ['patch', 'assign', id, path, [op.keys]]\n  }\n  if (op.type === 'replace') {\n    return [\n      'patch',\n      'replace',\n      id,\n      path,\n      [encodeItemRef(op.referenceItem), op.items],\n    ]\n  }\n  if (op.type === 'truncate') {\n    return ['patch', 'truncate', id, path, [op.startIndex, op.endIndex]]\n  }\n  if (op.type === 'remove') {\n    return ['patch', 'remove', id, path, [encodeItemRef(op.referenceItem)]]\n  }\n  // @ts-expect-error all cases are covered\n  throw new Error(`Invalid operation type: ${op.type}`)\n}\n\nfunction maybeAddRevision<T extends CompactPatchMutation>(\n  revision: string | undefined,\n  mut: T,\n): T {\n  const [mutType, patchType, id, path, args] = mut\n  return (revision ? [mutType, patchType, id, path, args, revision] : mut) as T\n}\n","// An example of a compact formatter\n\nimport {\n  type Mutation,\n  type NodePatch,\n  type SanityDocumentBase,\n} from '../mutations/types'\nimport {type Index, type KeyedPathElement, stringify} from '../path'\n\nexport type ItemRef = string | number\n\nexport function format<Doc extends SanityDocumentBase>(\n  mutations: Mutation[],\n): string {\n  return mutations.flatMap(m => encodeMutation<Doc>(m)).join('\\n')\n}\n\nfunction encodeItemRef(ref: Index | KeyedPathElement): ItemRef {\n  return typeof ref === 'number' ? ref : ref._key\n}\n\nfunction encodeMutation<Doc extends SanityDocumentBase>(\n  mutation: Mutation,\n): string {\n  if (\n    mutation.type === 'create' ||\n    mutation.type === 'createIfNotExists' ||\n    mutation.type === 'createOrReplace'\n  ) {\n    return [mutation.type, ': ', JSON.stringify(mutation.document)].join('')\n  }\n  if (mutation.type === 'delete') {\n    return ['delete ', mutation.id].join(': ')\n  }\n  if (mutation.type === 'patch') {\n    const ifRevision = mutation.options?.ifRevision\n    return [\n      'patch',\n      ' ',\n      `id=${mutation.id}`,\n      ifRevision ? ` (if revision==${ifRevision})` : '',\n      ':\\n',\n      mutation.patches\n        .map(nodePatch => `  ${formatPatchMutation(nodePatch)}`)\n        .join('\\n'),\n    ].join('')\n  }\n\n  //@ts-expect-error - all cases are covered\n  throw new Error(`Invalid mutation type: ${mutation.type}`)\n}\n\nfunction formatPatchMutation(patch: NodePatch<any>): string {\n  const {op} = patch\n  const path = stringify(patch.path)\n  if (op.type === 'unset') {\n    return [path, 'unset()'].join(': ')\n  }\n  if (op.type === 'diffMatchPatch') {\n    return [path, `diffMatchPatch(${op.value})`].join(': ')\n  }\n  if (op.type === 'inc' || op.type === 'dec') {\n    return [path, `${op.type}(${op.amount})`].join(': ')\n  }\n  if (op.type === 'set' || op.type === 'setIfMissing') {\n    return [path, `${op.type}(${JSON.stringify(op.value)})`].join(': ')\n  }\n  if (op.type === 'assign') {\n    return [path, `${op.type}(${JSON.stringify(op.value)})`].join(': ')\n  }\n  if (op.type === 'unassign') {\n    return [path, `${op.type}(${JSON.stringify(op.keys)})`].join(': ')\n  }\n  if (op.type === 'insert' || op.type === 'upsert') {\n    return [\n      path,\n      `${op.type}(${op.position}, ${encodeItemRef(\n        op.referenceItem,\n      )}, ${JSON.stringify(op.items)})`,\n    ].join(': ')\n  }\n  if (op.type === 'replace') {\n    return [\n      path,\n      `replace(${encodeItemRef(op.referenceItem)}, ${JSON.stringify(\n        op.items,\n      )})`,\n    ].join(': ')\n  }\n  if (op.type === 'truncate') {\n    return [path, `truncate(${op.startIndex}, ${op.endIndex}`].join(': ')\n  }\n  if (op.type === 'remove') {\n    return [path, `remove(${encodeItemRef(op.referenceItem)})`].join(': ')\n  }\n  // @ts-expect-error all cases are covered\n  throw new Error(`Invalid operation type: ${op.type}`)\n}\n","import {arrify} from '../../utils/arrify'\nimport {\n  type AnyArray,\n  type ArrayElement,\n  type NormalizeReadOnlyArray,\n} from '../../utils/typeUtils'\nimport {\n  type AssignOp,\n  type DecOp,\n  type DiffMatchPatchOp,\n  type IncOp,\n  type Index,\n  type InsertOp,\n  type KeyedPathElement,\n  type RelativePosition,\n  type RemoveOp,\n  type ReplaceOp,\n  type SetIfMissingOp,\n  type SetOp,\n  type TruncateOp,\n  type UnassignOp,\n  type UnsetOp,\n  type UpsertOp,\n} from './types'\n\nexport const set = <const T>(value: T): SetOp<T> => ({type: 'set', value})\n\nexport const assign = <const T extends {[K in string]: unknown}>(\n  value: T,\n): AssignOp<T> => ({\n  type: 'assign',\n  value,\n})\n\nexport const unassign = <const K extends readonly string[]>(\n  keys: K,\n): UnassignOp<K> => ({\n  type: 'unassign',\n  keys,\n})\n\nexport const setIfMissing = <const T>(value: T): SetIfMissingOp<T> => ({\n  type: 'setIfMissing',\n  value,\n})\n\nexport const unset = (): UnsetOp => ({type: 'unset'})\n\nexport const inc = <const N extends number = 1>(\n  amount: N = 1 as N,\n): IncOp<N> => ({\n  type: 'inc',\n  amount,\n})\n\nexport const dec = <const N extends number = 1>(\n  amount: N = 1 as N,\n): DecOp<N> => ({\n  type: 'dec',\n  amount,\n})\n\nexport const diffMatchPatch = (value: string): DiffMatchPatchOp => ({\n  type: 'diffMatchPatch',\n  value,\n})\n\nexport function insert<\n  const Items extends AnyArray<unknown>,\n  const Pos extends RelativePosition,\n  const ReferenceItem extends Index | KeyedPathElement,\n>(\n  items: Items | ArrayElement<Items>,\n  position: Pos,\n  indexOrReferenceItem: ReferenceItem,\n): InsertOp<NormalizeReadOnlyArray<Items>, Pos, ReferenceItem> {\n  return {\n    type: 'insert',\n    referenceItem: indexOrReferenceItem,\n    position,\n    items: arrify(items) as any,\n  }\n}\n\nexport function append<const Items extends AnyArray<unknown>>(\n  items: Items | ArrayElement<Items>,\n) {\n  return insert(items, 'after', -1)\n}\n\nexport function prepend<const Items extends AnyArray<unknown>>(\n  items: Items | ArrayElement<Items>,\n) {\n  return insert(items, 'before', 0)\n}\n\nexport function insertBefore<\n  const Items extends AnyArray<unknown>,\n  const ReferenceItem extends Index | KeyedPathElement,\n>(items: Items | ArrayElement<Items>, indexOrReferenceItem: ReferenceItem) {\n  return insert(items, 'before', indexOrReferenceItem)\n}\n\nexport const insertAfter = <\n  const Items extends AnyArray<unknown>,\n  const ReferenceItem extends Index | KeyedPathElement,\n>(\n  items: Items | ArrayElement<Items>,\n  indexOrReferenceItem: ReferenceItem,\n) => {\n  return insert(items, 'after', indexOrReferenceItem)\n}\n\nexport function truncate(startIndex: number, endIndex?: number): TruncateOp {\n  return {\n    type: 'truncate',\n    startIndex,\n    endIndex,\n  }\n}\n\n/*\n  Use this when you know the ref Items already exists\n */\nexport function replace<\n  Items extends any[],\n  ReferenceItem extends Index | KeyedPathElement,\n>(\n  items: Items | ArrayElement<Items>,\n  referenceItem: ReferenceItem,\n): ReplaceOp<Items, ReferenceItem> {\n  return {\n    type: 'replace',\n    referenceItem,\n    items: arrify(items) as Items,\n  }\n}\n\n/*\n  Remove an item from an array by either key or index\n */\nexport function remove<ReferenceItem extends Index | KeyedPathElement>(\n  referenceItem: ReferenceItem,\n): RemoveOp<ReferenceItem> {\n  return {\n    type: 'remove',\n    referenceItem,\n  }\n}\n\n/*\nuse this when the reference Items may or may not exist\n */\nexport function upsert<\n  const Items extends AnyArray<unknown>,\n  const Pos extends RelativePosition,\n  const ReferenceItem extends Index | KeyedPathElement,\n>(\n  items: Items | ArrayElement<Items>,\n  position: Pos,\n  referenceItem: ReferenceItem,\n): UpsertOp<Items, Pos, ReferenceItem> {\n  return {\n    type: 'upsert',\n    items: arrify(items) as Items,\n    referenceItem,\n    position,\n  }\n}\n","import {type Index, type KeyedPathElement} from '../path'\nimport {isObject} from '../utils/isObject'\nimport {\n  insert as _insert,\n  replace as _replace,\n  upsert as _upsert,\n} from './operations/creators'\nimport {type RelativePosition} from './operations/types'\n\nexport function autoKeys<Item>(generateKey: (item: Item) => string) {\n  const ensureKeys = createEnsureKeys(generateKey)\n\n  const insert = <\n    Pos extends RelativePosition,\n    Ref extends Index | KeyedPathElement,\n  >(\n    position: Pos,\n    referenceItem: Ref,\n    items: Item[],\n  ) => _insert(ensureKeys(items), position, referenceItem)\n  const upsert = <\n    Pos extends RelativePosition,\n    ReferenceItem extends Index | KeyedPathElement,\n  >(\n    items: Item[],\n    position: Pos,\n    referenceItem: ReferenceItem,\n  ) => _upsert(ensureKeys(items), position, referenceItem)\n\n  const replace = <\n    Pos extends RelativePosition,\n    ReferenceItem extends Index | KeyedPathElement,\n  >(\n    items: Item[],\n    position: Pos,\n    referenceItem: ReferenceItem,\n  ) => _replace(ensureKeys(items), referenceItem)\n\n  const insertBefore = <Ref extends Index | KeyedPathElement>(\n    ref: Ref,\n    items: Item[],\n  ) => insert('before', ref, items)\n\n  const prepend = (items: Item[]) => insertBefore(0, items)\n\n  const insertAfter = <Ref extends Index | KeyedPathElement>(\n    ref: Ref,\n    items: Item[],\n  ) => insert('after', ref, items)\n\n  const append = (items: Item[]) => insert('after', -1, items)\n\n  return {insert, upsert, replace, insertBefore, prepend, insertAfter, append}\n}\n\nfunction hasKey<T extends object>(item: T): item is T & {_key: string} {\n  return '_key' in item\n}\n\nfunction createEnsureKeys<T>(generateKey: (item: T) => string) {\n  return (array: T[]): T[] => {\n    let didModify = false\n    const withKeys = array.map(item => {\n      if (needsKey(item)) {\n        didModify = true\n        return {...item, _key: generateKey(item)}\n      }\n      return item\n    })\n    return didModify ? withKeys : array\n  }\n}\n\nfunction needsKey(arrayItem: any): arrayItem is object {\n  return isObject(arrayItem) && !hasKey(arrayItem)\n}\n","import {parse, type Path, type SafePath} from '../path'\nimport {arrify} from '../utils/arrify'\nimport {\n  type NormalizeReadOnlyArray,\n  type Optional,\n  type Tuplify,\n} from '../utils/typeUtils'\nimport {type Operation} from './operations/types'\nimport {\n  type CreateIfNotExistsMutation,\n  type CreateMutation,\n  type CreateOrReplaceMutation,\n  type DeleteMutation,\n  type NodePatch,\n  type NodePatchList,\n  type PatchMutation,\n  type PatchOptions,\n  type SanityDocumentBase,\n} from './types'\n\nexport function create<Doc extends Optional<SanityDocumentBase, '_id'>>(\n  document: Doc,\n): CreateMutation<Doc> {\n  return {type: 'create', document}\n}\n\nexport function patch<P extends NodePatchList | NodePatch>(\n  id: string,\n  patches: P,\n  options?: PatchOptions,\n): PatchMutation<NormalizeReadOnlyArray<Tuplify<P>>> {\n  return {\n    type: 'patch',\n    id,\n    patches: arrify(patches) as any,\n    ...(options ? {options} : {}),\n  }\n}\n\nexport function at<const P extends Path, O extends Operation>(\n  path: P,\n  operation: O,\n): NodePatch<NormalizeReadOnlyArray<P>, O>\n\nexport function at<const P extends string, O extends Operation>(\n  path: P,\n  operation: O,\n): NodePatch<SafePath<P>, O>\n\nexport function at<O extends Operation>(\n  path: Path | string,\n  operation: O,\n): NodePatch<Path, O> {\n  return {\n    path: typeof path === 'string' ? parse(path) : path,\n    op: operation,\n  }\n}\n\nexport function createIfNotExists<Doc extends SanityDocumentBase>(\n  document: Doc,\n): CreateIfNotExistsMutation<Doc> {\n  return {type: 'createIfNotExists', document}\n}\n\nexport function createOrReplace<Doc extends SanityDocumentBase>(\n  document: Doc,\n): CreateOrReplaceMutation<Doc> {\n  return {type: 'createOrReplace', document}\n}\n\nexport function delete_(id: string): DeleteMutation {\n  return {type: 'delete', id}\n}\n\nexport const del = delete_\nexport const destroy = delete_\n"],"names":["parsePath","encodeMutation","encodeItemRef","patch","stringifyPath","insert","_insert","upsert","_upsert","replace","_replace","insertBefore"],"mappings":"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","debugId":null}},
    {"offset": {"line": 1107, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/projects/masterthepixel/node_modules/.pnpm/@sanity+mutate@0.11.0-canary.4_xstate@5.25.0/node_modules/@sanity/mutate/dist/_unstable_machine.browser.js","sources":["file:///home/sysadmin/projects/masterthepixel/node_modules/.pnpm/%40sanity%2Bmutate%400.11.0-canary.4_xstate%405.25.0/node_modules/%40sanity/mutate/src/store/utils/getMutationDocumentId.ts","file:///home/sysadmin/projects/masterthepixel/node_modules/.pnpm/%40sanity%2Bmutate%400.11.0-canary.4_xstate%405.25.0/node_modules/%40sanity/mutate/node_modules/.pnpm/nanoid%405.0.8/node_modules/nanoid/url-alphabet/index.js","file:///home/sysadmin/projects/masterthepixel/node_modules/.pnpm/%40sanity%2Bmutate%400.11.0-canary.4_xstate%405.25.0/node_modules/%40sanity/mutate/node_modules/.pnpm/nanoid%405.0.8/node_modules/nanoid/index.browser.js","file:///home/sysadmin/projects/masterthepixel/node_modules/.pnpm/%40sanity%2Bmutate%400.11.0-canary.4_xstate%405.25.0/node_modules/%40sanity/mutate/src/path/utils/predicates.ts","file:///home/sysadmin/projects/masterthepixel/node_modules/.pnpm/%40sanity%2Bmutate%400.11.0-canary.4_xstate%405.25.0/node_modules/%40sanity/mutate/src/path/get/getAtPath.ts","file:///home/sysadmin/projects/masterthepixel/node_modules/.pnpm/%40sanity%2Bmutate%400.11.0-canary.4_xstate%405.25.0/node_modules/%40sanity/mutate/src/path/parser/stringify.ts","file:///home/sysadmin/projects/masterthepixel/node_modules/.pnpm/%40sanity%2Bmutate%400.11.0-canary.4_xstate%405.25.0/node_modules/%40sanity/mutate/src/utils/isObject.ts","file:///home/sysadmin/projects/masterthepixel/node_modules/.pnpm/%40sanity%2Bmutate%400.11.0-canary.4_xstate%405.25.0/node_modules/%40sanity/mutate/src/apply/utils/getKeyOf.ts","file:///home/sysadmin/projects/masterthepixel/node_modules/.pnpm/%40sanity%2Bmutate%400.11.0-canary.4_xstate%405.25.0/node_modules/%40sanity/mutate/src/apply/utils/array.ts","file:///home/sysadmin/projects/masterthepixel/node_modules/.pnpm/%40sanity%2Bmutate%400.11.0-canary.4_xstate%405.25.0/node_modules/%40sanity/mutate/src/apply/patch/operations/array.ts","file:///home/sysadmin/projects/masterthepixel/node_modules/.pnpm/%40sanity%2Bmutate%400.11.0-canary.4_xstate%405.25.0/node_modules/%40sanity/mutate/src/apply/patch/operations/common.ts","file:///home/sysadmin/projects/masterthepixel/node_modules/.pnpm/%40sanity%2Bmutate%400.11.0-canary.4_xstate%405.25.0/node_modules/%40sanity/mutate/src/apply/patch/operations/number.ts","file:///home/sysadmin/projects/masterthepixel/node_modules/.pnpm/%40sanity%2Bmutate%400.11.0-canary.4_xstate%405.25.0/node_modules/%40sanity/mutate/src/apply/utils/hasOwn.ts","file:///home/sysadmin/projects/masterthepixel/node_modules/.pnpm/%40sanity%2Bmutate%400.11.0-canary.4_xstate%405.25.0/node_modules/%40sanity/mutate/src/apply/utils/isEmpty.ts","file:///home/sysadmin/projects/masterthepixel/node_modules/.pnpm/%40sanity%2Bmutate%400.11.0-canary.4_xstate%405.25.0/node_modules/%40sanity/mutate/src/apply/utils/omit.ts","file:///home/sysadmin/projects/masterthepixel/node_modules/.pnpm/%40sanity%2Bmutate%400.11.0-canary.4_xstate%405.25.0/node_modules/%40sanity/mutate/src/apply/patch/operations/object.ts","file:///home/sysadmin/projects/masterthepixel/node_modules/.pnpm/%40sanity%2Bmutate%400.11.0-canary.4_xstate%405.25.0/node_modules/%40sanity/mutate/src/apply/patch/operations/string.ts","file:///home/sysadmin/projects/masterthepixel/node_modules/.pnpm/%40sanity%2Bmutate%400.11.0-canary.4_xstate%405.25.0/node_modules/%40sanity/mutate/src/apply/patch/applyOp.ts","file:///home/sysadmin/projects/masterthepixel/node_modules/.pnpm/%40sanity%2Bmutate%400.11.0-canary.4_xstate%405.25.0/node_modules/%40sanity/mutate/src/apply/patch/applyNodePatch.ts","file:///home/sysadmin/projects/masterthepixel/node_modules/.pnpm/%40sanity%2Bmutate%400.11.0-canary.4_xstate%405.25.0/node_modules/%40sanity/mutate/src/apply/applyPatchMutation.ts","file:///home/sysadmin/projects/masterthepixel/node_modules/.pnpm/%40sanity%2Bmutate%400.11.0-canary.4_xstate%405.25.0/node_modules/%40sanity/mutate/src/apply/store/utils.ts","file:///home/sysadmin/projects/masterthepixel/node_modules/.pnpm/%40sanity%2Bmutate%400.11.0-canary.4_xstate%405.25.0/node_modules/%40sanity/mutate/src/store/datasets/applyDocumentMutation.ts","file:///home/sysadmin/projects/masterthepixel/node_modules/.pnpm/%40sanity%2Bmutate%400.11.0-canary.4_xstate%405.25.0/node_modules/%40sanity/mutate/src/store/datasets/applyMutations.ts","file:///home/sysadmin/projects/masterthepixel/node_modules/.pnpm/%40sanity%2Bmutate%400.11.0-canary.4_xstate%405.25.0/node_modules/%40sanity/mutate/src/store/datasets/commit.ts","file:///home/sysadmin/projects/masterthepixel/node_modules/.pnpm/%40sanity%2Bmutate%400.11.0-canary.4_xstate%405.25.0/node_modules/%40sanity/mutate/src/store/utils/arrayUtils.ts","file:///home/sysadmin/projects/masterthepixel/node_modules/.pnpm/%40sanity%2Bmutate%400.11.0-canary.4_xstate%405.25.0/node_modules/%40sanity/mutate/src/store/optimizations/squashNodePatches.ts","file:///home/sysadmin/projects/masterthepixel/node_modules/.pnpm/%40sanity%2Bmutate%400.11.0-canary.4_xstate%405.25.0/node_modules/%40sanity/mutate/src/store/optimizations/squashDMPStrings.ts","file:///home/sysadmin/projects/masterthepixel/node_modules/.pnpm/%40sanity%2Bmutate%400.11.0-canary.4_xstate%405.25.0/node_modules/%40sanity/mutate/src/store/utils/mergeMutationGroups.ts","file:///home/sysadmin/projects/masterthepixel/node_modules/.pnpm/%40sanity%2Bmutate%400.11.0-canary.4_xstate%405.25.0/node_modules/%40sanity/mutate/src/store/optimizations/squashMutations.ts","file:///home/sysadmin/projects/masterthepixel/node_modules/.pnpm/%40sanity%2Bmutate%400.11.0-canary.4_xstate%405.25.0/node_modules/%40sanity/mutate/src/store/rebase.ts","file:///home/sysadmin/projects/masterthepixel/node_modules/.pnpm/%40sanity%2Bmutate%400.11.0-canary.4_xstate%405.25.0/node_modules/%40sanity/mutate/src/store/toTransactions.ts","file:///home/sysadmin/projects/masterthepixel/node_modules/.pnpm/%40sanity%2Bmutate%400.11.0-canary.4_xstate%405.25.0/node_modules/%40sanity/mutate/src/encoders/sanity/encode.ts","file:///home/sysadmin/projects/masterthepixel/node_modules/.pnpm/%40sanity%2Bmutate%400.11.0-canary.4_xstate%405.25.0/node_modules/%40sanity/mutate/src/machine/listener.ts","file:///home/sysadmin/projects/masterthepixel/node_modules/.pnpm/%40sanity%2Bmutate%400.11.0-canary.4_xstate%405.25.0/node_modules/%40sanity/mutate/src/machine/documentMutatorMachine.ts"],"sourcesContent":["type MutationLike =\n  | {type: 'patch'; id: string}\n  | {type: 'create'; document: {_id: string}}\n  | {type: 'delete'; id: string}\n  | {type: 'createIfNotExists'; document: {_id: string}}\n  | {type: 'createOrReplace'; document: {_id: string}}\n\nexport function getMutationDocumentId(mutation: MutationLike): string {\n  if (mutation.type === 'patch') {\n    return mutation.id\n  }\n  if (mutation.type === 'create') {\n    return mutation.document._id\n  }\n  if (mutation.type === 'delete') {\n    return mutation.id\n  }\n  if (mutation.type === 'createIfNotExists') {\n    return mutation.document._id\n  }\n  if (mutation.type === 'createOrReplace') {\n    return mutation.document._id\n  }\n  throw new Error('Invalid mutation type')\n}\n","export const urlAlphabet =\n  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'\n","import { urlAlphabet as scopedUrlAlphabet } from './url-alphabet/index.js'\nexport { urlAlphabet } from './url-alphabet/index.js'\nexport let random = bytes => crypto.getRandomValues(new Uint8Array(bytes))\nexport let customRandom = (alphabet, defaultSize, getRandom) => {\n  let mask = (2 << Math.log2(alphabet.length - 1)) - 1\n  let step = -~((1.6 * mask * defaultSize) / alphabet.length)\n  return (size = defaultSize) => {\n    let id = ''\n    while (true) {\n      let bytes = getRandom(step)\n      let j = step\n      while (j--) {\n        id += alphabet[bytes[j] & mask] || ''\n        if (id.length === size) return id\n      }\n    }\n  }\n}\nexport let customAlphabet = (alphabet, size = 21) =>\n  customRandom(alphabet, size, random)\nexport let nanoid = (size = 21) => {\n  let id = ''\n  let bytes = crypto.getRandomValues(new Uint8Array(size))\n  while (size--) {\n    id += scopedUrlAlphabet[bytes[size] & 63]\n  }\n  return id\n}\n","import {type KeyedPathElement, type Path, type PathElement} from '../types'\n\nfunction safeGetElementAt<T>(array: T[] | readonly T[], index: number): T {\n  if (index < 0 || index >= array.length) {\n    throw new Error('Index out of bounds')\n  }\n  return array[index]!\n}\n\nexport function startsWith(parentPath: Path, path: Path): boolean {\n  return (\n    parentPath.length <= path.length &&\n    parentPath.every((segment, i) =>\n      isElementEqual(segment, safeGetElementAt(path, i)),\n    )\n  )\n}\n\nexport function isEqual(path: Path, otherPath: Path): boolean {\n  return (\n    path.length === otherPath.length &&\n    path.every((segment, i) =>\n      isElementEqual(segment, safeGetElementAt(path, i)),\n    )\n  )\n}\n\nexport function isElementEqual(\n  segmentA: PathElement,\n  segmentB: PathElement,\n): boolean {\n  if (isKeyElement(segmentA) && isKeyElement(segmentB)) {\n    return segmentA._key === segmentB._key\n  }\n\n  if (isIndexElement(segmentA)) {\n    return Number(segmentA) === Number(segmentB)\n  }\n\n  return segmentA === segmentB\n}\n\nexport function isKeyElement(\n  segment: PathElement,\n): segment is KeyedPathElement {\n  return typeof (segment as any)?._key === 'string'\n}\nexport function isIndexElement(segment: PathElement): segment is number {\n  return typeof segment === 'number'\n}\n\nexport function isKeyedElement(\n  element: PathElement,\n): element is KeyedPathElement {\n  return (\n    typeof element === 'object' &&\n    '_key' in element &&\n    typeof element._key === 'string'\n  )\n}\nexport function isArrayElement(\n  element: PathElement,\n): element is KeyedPathElement | number {\n  return typeof element === 'number' || isKeyedElement(element)\n}\n\nexport function isPropertyElement(element: PathElement): element is string {\n  return typeof element === 'string'\n}\n","import {type AnyArray} from '../../utils/typeUtils'\nimport {type KeyedPathElement, type Path, type PathElement} from '../types'\nimport {isArrayElement, isKeyedElement} from '../utils/predicates'\nimport {type FindInArray} from './types'\n\nexport type {AnyArray} from '../../utils/typeUtils'\n\nexport type Get<\n  P extends number | KeyedPathElement | Readonly<KeyedPathElement> | string,\n  T,\n> = T extends AnyArray\n  ? P extends KeyedPathElement | Readonly<KeyedPathElement> | number\n    ? FindInArray<P, T>\n    : undefined\n  : P extends keyof T\n    ? T[P]\n    : never\n\nexport type GetAtPath<P extends readonly PathElement[], T> = P extends []\n  ? T\n  : P extends [infer Head, ...infer Tail]\n    ? Head extends PathElement\n      ? Tail extends PathElement[]\n        ? GetAtPath<Tail, Get<Head, T>>\n        : undefined\n      : undefined\n    : undefined\n\nexport function getAtPath<const Head extends PathElement, const T>(\n  path: [head: Head],\n  value: T,\n): Get<Head, T>\nexport function getAtPath<\n  const Head extends PathElement,\n  const Tail extends PathElement[],\n  T,\n>(path: [head: Head, ...tail: Tail], value: T): GetAtPath<[Head, ...Tail], T>\nexport function getAtPath<T>(path: [], value: T): T\nexport function getAtPath(path: Path, value: unknown): unknown\nexport function getAtPath(path: Path, value: unknown): unknown {\n  if (path.length === 0) {\n    return value\n  }\n\n  let current = value\n  for (const head of path) {\n    if (isArrayElement(head)) {\n      if (!Array.isArray(current)) {\n        return undefined\n      }\n\n      if (isKeyedElement(head)) {\n        current = current.find(item => item._key === head._key)\n        continue\n      }\n      current = current[head]\n      continue\n    }\n    current = (current as any)[head]\n  }\n  return current\n}\n","import {type Path, type PathElement} from '../types'\nimport {isKeyedElement} from '../utils/predicates'\n\nconst IS_DOTTABLE = /^[a-z_$]+/\n\nfunction stringifySegment(segment: PathElement, hasLeading: boolean): string {\n  if (Array.isArray(segment)) {\n    return `[${segment[0]}:${segment[1] || ''}]`\n  }\n  const type = typeof segment\n\n  const isNumber = type === 'number'\n\n  if (isNumber) {\n    return `[${segment}]`\n  }\n\n  if (isKeyedElement(segment)) {\n    return `[_key==${JSON.stringify(segment._key)}]`\n  }\n\n  if (typeof segment === 'string' && IS_DOTTABLE.test(segment)) {\n    return hasLeading ? segment : `.${segment}`\n  }\n\n  return `['${segment}']`\n}\n\nexport function stringify(pathArray: Path): string {\n  return pathArray\n    .map((segment, i) => stringifySegment(segment, i === 0))\n    .join('')\n}\n","export function isObject(val: unknown): val is {\n  [K in string]: unknown\n} {\n  return val !== null && typeof val === 'object' && !Array.isArray(val)\n}\n","export function keyOf(value: any): string | null {\n  return (\n    (value !== null &&\n      typeof value === 'object' &&\n      typeof value._key === 'string' &&\n      value._key) ||\n    null\n  )\n}\n","import {isKeyedElement, type PathElement} from '../../path'\nimport {keyOf} from './getKeyOf'\n\nexport function findTargetIndex<T>(array: T[], pathSegment: PathElement) {\n  if (typeof pathSegment === 'number') {\n    return normalizeIndex(array.length, pathSegment)\n  }\n  if (isKeyedElement(pathSegment)) {\n    const idx = array.findIndex(value => keyOf(value) === pathSegment._key)\n    return idx === -1 ? null : idx\n  }\n  throw new Error(\n    `Expected path segment to be addressing a single array item either by numeric index or by '_key'. Instead saw ${JSON.stringify(\n      pathSegment,\n    )}`,\n  )\n}\n\nexport function getTargetIdx(position: 'before' | 'after', index: number) {\n  return position === 'before' ? index : index + 1\n}\n\n// normalizes the index according to the array length\n// returns null if the normalized index is out of bounds\nexport function normalizeIndex(length: number, index: number) {\n  if (length === 0 && (index === -1 || index === 0)) {\n    return 0\n  }\n  const normalized = index < 0 ? length + index : index\n  return normalized >= length || normalized < 0 ? null : normalized\n}\n\n// non-mutating splice\nexport function splice<T>(arr: T[], start: number, deleteCount: number): T[]\nexport function splice<T>(\n  arr: T[],\n  start: number,\n  deleteCount: number,\n  items: T[],\n): T[]\nexport function splice<T>(\n  arr: T[],\n  start: number,\n  deleteCount: number,\n  items?: T[],\n): T[] {\n  const copy = arr.slice()\n  copy.splice(start, deleteCount, ...(items || []))\n  return copy\n}\n","import {\n  type InsertOp,\n  type KeyedPathElement,\n  type RelativePosition,\n  type RemoveOp,\n  type ReplaceOp,\n  type TruncateOp,\n  type UpsertOp,\n} from '../../../mutations/operations/types'\nimport {findTargetIndex, getTargetIdx, splice} from '../../utils/array'\n\nexport function insert<\n  O extends InsertOp<unknown[], RelativePosition, number | KeyedPathElement>,\n  CurrentValue extends unknown[],\n>(op: O, currentValue: CurrentValue) {\n  if (!Array.isArray(currentValue)) {\n    throw new TypeError('Cannot apply \"insert()\" on non-array value')\n  }\n\n  const index = findTargetIndex(currentValue, op.referenceItem)\n  if (index === null) {\n    throw new Error(`Found no matching array element to insert ${op.position}`)\n  }\n  // special case for empty arrays\n  if (currentValue.length === 0) {\n    return op.items\n  }\n  return splice(currentValue, getTargetIdx(op.position, index), 0, op.items)\n}\n\nexport function upsert<\n  O extends UpsertOp<unknown[], RelativePosition, number | KeyedPathElement>,\n  CurrentValue extends unknown[],\n>(op: O, currentValue: CurrentValue) {\n  if (!Array.isArray(currentValue)) {\n    throw new TypeError('Cannot apply \"upsert()\" on non-array value')\n  }\n\n  if (op.items.length === 0) {\n    return currentValue\n  }\n  const replaceItemsMap: number[] = []\n  const insertItems: unknown[] = []\n  op.items.forEach((itemToBeUpserted: any, i) => {\n    const existingIndex = currentValue.findIndex(\n      existingItem => (existingItem as any)?._key === itemToBeUpserted._key,\n    )\n    if (existingIndex >= 0) {\n      replaceItemsMap[existingIndex] = i\n    } else {\n      insertItems.push(itemToBeUpserted)\n    }\n  })\n\n  if (replaceItemsMap.length === 0 && insertItems.length == 0) {\n    return currentValue\n  }\n\n  const next = [...currentValue]\n  // Replace existing items\n  for (const i of replaceItemsMap) {\n    next[i] = op.items[replaceItemsMap[i]!]!\n  }\n\n  // Insert the items that doesn't exist\n  return insert(\n    {\n      type: 'insert',\n      items: insertItems,\n      referenceItem: op.referenceItem,\n      position: op.position,\n    },\n    next,\n  )\n}\n\nexport function replace<\n  O extends ReplaceOp<unknown[], number | KeyedPathElement>,\n  CurrentValue extends unknown[],\n>(op: O, currentValue: CurrentValue) {\n  if (!Array.isArray(currentValue)) {\n    throw new TypeError('Cannot apply \"replace()\" on non-array value')\n  }\n\n  const index = findTargetIndex(currentValue, op.referenceItem)\n  if (index === null) {\n    throw new Error(`Found no matching array element to replace`)\n  }\n  return splice(currentValue, index, op.items.length, op.items)\n}\nexport function remove<\n  O extends RemoveOp<number | KeyedPathElement>,\n  CurrentValue extends unknown[],\n>(op: O, currentValue: CurrentValue) {\n  if (!Array.isArray(currentValue)) {\n    throw new TypeError('Cannot apply \"remove()\" on non-array value')\n  }\n\n  const index = findTargetIndex(currentValue, op.referenceItem)\n  if (index === null) {\n    throw new Error(`Found no matching array element to replace`)\n  }\n  return splice(currentValue, index, 1, [])\n}\n\nexport function truncate<O extends TruncateOp, CurrentValue extends unknown[]>(\n  op: O,\n  currentValue: CurrentValue,\n) {\n  if (!Array.isArray(currentValue)) {\n    throw new TypeError('Cannot apply \"truncate()\" on non-array value')\n  }\n\n  return typeof op.endIndex === 'number'\n    ? currentValue\n        .slice(0, op.startIndex)\n        .concat(currentValue.slice(op.endIndex))\n    : currentValue.slice(0, op.startIndex)\n}\n","import {\n  type SetIfMissingOp,\n  type SetOp,\n  type UnsetOp,\n} from '../../../mutations/operations/types'\n\nexport function set<O extends SetOp<any>, CurrentValue>(\n  op: O,\n  currentValue: CurrentValue,\n) {\n  return op.value\n}\n\nexport function setIfMissing<O extends SetIfMissingOp<any>, CurrentValue>(\n  op: O,\n  currentValue: CurrentValue,\n) {\n  return currentValue ?? op.value\n}\n\nexport function unset<O extends UnsetOp, CurrentValue>(op: O) {\n  return undefined\n}\n","import {type DecOp, type IncOp} from '../../../mutations/operations/types'\n\nexport function inc<O extends IncOp<number>, CurrentValue extends number>(\n  op: O,\n  currentValue: CurrentValue,\n) {\n  if (typeof currentValue !== 'number') {\n    throw new TypeError('Cannot apply \"inc()\" on non-numeric value')\n  }\n\n  return currentValue + op.amount\n}\n\nexport function dec<O extends DecOp<number>, CurrentValue extends number>(\n  op: O,\n  currentValue: CurrentValue,\n) {\n  if (typeof currentValue !== 'number') {\n    throw new TypeError('Cannot apply \"dec()\" on non-numeric value')\n  }\n\n  return currentValue - op.amount\n}\n","export const hasOwn = Object.prototype.hasOwnProperty.call.bind(\n  Object.prototype.hasOwnProperty,\n)\n","import {hasOwn} from './hasOwn'\n\nexport function isEmpty(v: object) {\n  for (const key in v) {\n    if (hasOwn(v, key)) {\n      return false\n    }\n  }\n  return true\n}\n","export function omit<T, K extends keyof T>(val: T, props: K[]): Omit<T, K> {\n  const copy = {...val}\n  for (const prop of props) {\n    delete copy[prop]\n  }\n  return copy\n}\n","import {\n  type AssignOp,\n  type UnassignOp,\n} from '../../../mutations/operations/types'\nimport {isObject} from '../../../utils/isObject'\nimport {isEmpty} from '../../utils/isEmpty'\nimport {omit} from '../../utils/omit'\n\nexport function unassign<T extends object, K extends string[]>(\n  op: UnassignOp<K>,\n  currentValue: T,\n) {\n  if (!isObject(currentValue)) {\n    throw new TypeError('Cannot apply \"unassign()\" on non-object value')\n  }\n\n  return op.keys.length === 0\n    ? currentValue\n    : omit(currentValue, op.keys as any[])\n}\n\nexport function assign<T extends object>(op: AssignOp<T>, currentValue: T) {\n  if (!isObject(currentValue)) {\n    throw new TypeError('Cannot apply \"assign()\" on non-object value')\n  }\n\n  return isEmpty(op.value) ? currentValue : {...currentValue, ...op.value}\n}\n","import {applyPatches, parsePatch} from '@sanity/diff-match-patch'\n\nimport {type DiffMatchPatchOp} from '../../../mutations/operations/types'\n\nexport function diffMatchPatch<\n  O extends DiffMatchPatchOp,\n  CurrentValue extends string,\n>(op: O, currentValue: CurrentValue) {\n  if (typeof currentValue !== 'string') {\n    throw new TypeError('Cannot apply \"diffMatchPatch()\" on non-string value')\n  }\n\n  return applyPatches(parsePatch(op.value), currentValue)[0]\n}\n","import {\n  type AnyOp,\n  type ArrayOp,\n  type NumberOp,\n  type ObjectOp,\n  type Operation,\n  type StringOp,\n} from '../../mutations/operations/types'\nimport {type AnyArray} from '../../utils/typeUtils'\nimport * as operations from './operations'\nimport {type ApplyOp} from './typings/applyOp'\n\nexport function applyOp<const Op extends AnyOp, const CurrentValue>(\n  op: Op,\n  currentValue: CurrentValue,\n): ApplyOp<Op, CurrentValue>\nexport function applyOp<\n  const Op extends NumberOp,\n  const CurrentValue extends number,\n>(op: Op, currentValue: CurrentValue): ApplyOp<Op, CurrentValue>\nexport function applyOp<\n  const Op extends StringOp,\n  const CurrentValue extends string,\n>(op: Op, currentValue: CurrentValue): ApplyOp<Op, CurrentValue>\nexport function applyOp<\n  const Op extends ObjectOp,\n  const CurrentValue extends {[k in keyof any]: unknown},\n>(op: Op, currentValue: CurrentValue): ApplyOp<Op, CurrentValue>\nexport function applyOp<\n  const Op extends ArrayOp,\n  const CurrentValue extends AnyArray,\n>(op: Op, currentValue: CurrentValue): ApplyOp<Op, CurrentValue>\nexport function applyOp<const Op extends Operation, const CurrentValue>(\n  op: Op,\n  currentValue: CurrentValue,\n): ApplyOp<Op, CurrentValue> {\n  if (!(op.type in operations)) {\n    throw new Error(`Invalid operation type: \"${op.type}\"`)\n  }\n\n  return (operations[op.type] as CallableFunction)(op, currentValue)\n}\n","import {type Operation} from '../../mutations/operations/types'\nimport {type NodePatch, type NodePatchList} from '../../mutations/types'\nimport {isArrayElement, isPropertyElement, stringify} from '../../path'\nimport {isObject} from '../../utils/isObject'\nimport {type NormalizeReadOnlyArray} from '../../utils/typeUtils'\nimport {type KeyedPathElement, type Path} from '../'\nimport {findTargetIndex, splice} from '../utils/array'\nimport {applyOp} from './applyOp'\nimport {\n  type ApplyAtPath,\n  type ApplyNodePatch,\n  type ApplyPatches,\n} from './typings/applyNodePatch'\n\nexport function applyPatches<Patches extends NodePatchList, const Doc>(\n  patches: Patches,\n  document: Doc,\n): ApplyPatches<NormalizeReadOnlyArray<Patches>, Doc> {\n  return (patches as NodePatch[]).reduce(\n    (prev, patch) => applyNodePatch(patch, prev) as any,\n    document,\n  ) as any\n}\n\nexport function applyNodePatch<const Patch extends NodePatch, const Doc>(\n  patch: Patch,\n  document: Doc,\n): ApplyNodePatch<Patch, Doc> {\n  return applyAtPath(patch.path, patch.op, document) as any\n}\n\nfunction applyAtPath<P extends Path, O extends Operation, T>(\n  path: P,\n  op: O,\n  value: T,\n): ApplyAtPath<P, O, T> {\n  if (!isNonEmptyArray(path)) {\n    return applyOp(op as any, value) as any\n  }\n\n  const [head, ...tail] = path\n\n  if (isArrayElement(head) && Array.isArray(value)) {\n    return applyInArray(head, tail, op, value) as any\n  }\n\n  if (isPropertyElement(head) && isObject(value)) {\n    return applyInObject(head, tail, op, value) as any\n  }\n\n  throw new Error(\n    `Cannot apply operation of type \"${op.type}\" to path ${stringify(\n      path,\n    )} on ${typeof value} value`,\n  )\n}\n\nfunction applyInObject<Key extends keyof any, T extends {[key in Key]?: any}>(\n  head: Key,\n  tail: Path,\n  op: Operation,\n  object: T,\n) {\n  const current = object[head]\n\n  if (current === undefined && tail.length > 0) {\n    return object\n  }\n\n  // The patch targets the item at the index specified by \"head\"\n  // so forward it to the item\n  const patchedValue = applyAtPath(tail, op, current)\n\n  // If the result of applying it to the item yields the item back we assume it was\n  // a noop and don't modify our value. If we get a new value back, we return a\n  // new array with the modified item replaced\n  return patchedValue === current ? object : {...object, [head]: patchedValue}\n}\n\nfunction applyInArray<T>(\n  head: number | KeyedPathElement,\n  tail: Path,\n  op: Operation,\n  value: T[],\n) {\n  const index = findTargetIndex(value, head!)\n\n  if (index === null) {\n    // partial is default behavior for arrays\n    // the patch targets an index that is out of bounds\n    return value\n  }\n\n  // If the given selector could not be found, return as-is\n  if (index === -1) {\n    return value\n  }\n\n  const current = value[index]!\n\n  // The patch targets the item at the index specified by \"head\"\n  // so forward it to the item\n  const patchedItem = applyAtPath(tail, op, current)\n\n  // If the result of applying it to the item yields the item back we assume it was\n  // a noop and don't modify our value. If we get a new value back, we return a\n  // new array with the modified item replaced\n  return patchedItem === current\n    ? value\n    : splice(value, index, 1, [patchedItem])\n}\n\nfunction isNonEmptyArray<T>(a: T[] | readonly T[]): a is [T, ...T[]] {\n  return a.length > 0\n}\n","import {type PatchMutation, type SanityDocumentBase} from '../mutations/types'\nimport {type NormalizeReadOnlyArray} from '../utils/typeUtils'\nimport {applyPatches} from './patch/applyNodePatch'\nimport {type ApplyPatches} from './patch/typings/applyNodePatch'\n\nexport type ApplyPatchMutation<\n  Mutation extends PatchMutation,\n  Doc extends SanityDocumentBase,\n> =\n  Mutation extends PatchMutation<infer Patches>\n    ? ApplyPatches<NormalizeReadOnlyArray<Patches>, Doc>\n    : Doc\n\nexport function applyPatchMutation<\n  const Mutation extends PatchMutation,\n  const Doc extends SanityDocumentBase,\n>(mutation: Mutation, document: Doc): ApplyPatchMutation<Mutation, Doc> {\n  if (\n    mutation.options?.ifRevision &&\n    document._rev !== mutation.options.ifRevision\n  ) {\n    throw new Error('Revision mismatch')\n  }\n  if (mutation.id !== document._id) {\n    throw new Error(\n      `Document id mismatch. Refusing to apply mutation for document with id=\"${mutation.id}\" on the given document with id=\"${document._id}\"`,\n    )\n  }\n  return applyPatches(mutation.patches, document) as any\n}\n","import {type SanityDocumentBase} from '../../mutations/types'\nimport {type StoredDocument} from '../applyInIndex'\n\nexport function hasId(doc: SanityDocumentBase): doc is StoredDocument {\n  return '_id' in doc\n}\nexport function assignId<Doc extends SanityDocumentBase>(\n  doc: Doc,\n  generateId: () => string,\n): Doc & {_id: string} {\n  return hasId(doc) ? doc : {...doc, _id: generateId()}\n}\n","import {nanoid} from 'nanoid'\n\nimport {applyPatchMutation, assignId, hasId} from '../../apply'\nimport {\n  type CreateIfNotExistsMutation,\n  type CreateMutation,\n  type CreateOrReplaceMutation,\n  type DeleteMutation,\n  type Mutation,\n  type PatchMutation,\n  type SanityDocumentBase,\n} from '../../mutations/types'\n\nexport type MutationResult<Doc extends SanityDocumentBase> =\n  | {\n      id: string\n      status: 'created'\n      after: Doc\n    }\n  | {\n      id: string\n      status: 'updated'\n      before: Doc\n      after: Doc\n    }\n  | {\n      id: string\n      status: 'deleted'\n      before: Doc | undefined\n      after: undefined\n    }\n  | {\n      status: 'error'\n      message: string\n    }\n  | {\n      status: 'noop'\n    }\n\n/**\n * Applies a set of mutations to the provided document\n * @param current\n * @param mutation\n */\nexport function applyAll<Doc extends SanityDocumentBase>(\n  current: Doc | undefined,\n  mutation: Mutation<Doc>[],\n): Doc | undefined {\n  return mutation.reduce((doc, m) => {\n    const res = applyDocumentMutation(doc, m)\n    if (res.status === 'error') {\n      throw new Error(res.message)\n    }\n    return res.status === 'noop' ? doc : res.after\n  }, current)\n}\n\n/**\n * Applies a mutation to the provided document\n * @param document\n * @param mutation\n */\nexport function applyDocumentMutation<Doc extends SanityDocumentBase>(\n  document: Doc | undefined,\n  mutation: Mutation<Doc>,\n): MutationResult<Doc> {\n  if (mutation.type === 'create') {\n    return create(document, mutation)\n  }\n  if (mutation.type === 'createIfNotExists') {\n    return createIfNotExists(document, mutation)\n  }\n  if (mutation.type === 'delete') {\n    return del(document, mutation)\n  }\n  if (mutation.type === 'createOrReplace') {\n    return createOrReplace(document, mutation)\n  }\n  if (mutation.type === 'patch') {\n    return patch(document, mutation)\n  }\n  // @ts-expect-error all cases should be covered\n  throw new Error(`Invalid mutation type: ${mutation.type}`)\n}\n\nfunction create<Doc extends SanityDocumentBase>(\n  document: Doc | undefined,\n  mutation: CreateMutation<Doc>,\n): MutationResult<Doc> {\n  if (document) {\n    return {status: 'error', message: 'Document already exist'}\n  }\n  const result = assignId(mutation.document, nanoid)\n  return {status: 'created', id: result._id, after: result}\n}\n\nfunction createIfNotExists<Doc extends SanityDocumentBase>(\n  document: Doc | undefined,\n  mutation: CreateIfNotExistsMutation<Doc>,\n): MutationResult<Doc> {\n  if (!hasId(mutation.document)) {\n    return {\n      status: 'error',\n      message: 'Cannot createIfNotExists on document without _id',\n    }\n  }\n  return document\n    ? {status: 'noop'}\n    : {status: 'created', id: mutation.document._id, after: mutation.document}\n}\n\nfunction createOrReplace<Doc extends SanityDocumentBase>(\n  document: Doc | undefined,\n  mutation: CreateOrReplaceMutation<Doc>,\n): MutationResult<Doc> {\n  if (!hasId(mutation.document)) {\n    return {\n      status: 'error',\n      message: 'Cannot createIfNotExists on document without _id',\n    }\n  }\n\n  return document\n    ? {\n        status: 'updated',\n        id: mutation.document._id,\n        before: document,\n        after: mutation.document,\n      }\n    : {status: 'created', id: mutation.document._id, after: mutation.document}\n}\n\nfunction del<Doc extends SanityDocumentBase>(\n  document: Doc | undefined,\n  mutation: DeleteMutation,\n): MutationResult<Doc> {\n  if (!document) {\n    return {status: 'noop'}\n  }\n  if (mutation.id !== document._id) {\n    return {status: 'error', message: 'Delete mutation targeted wrong document'}\n  }\n  return {\n    status: 'deleted',\n    id: mutation.id,\n    before: document,\n    after: undefined,\n  }\n}\n\nfunction patch<Doc extends SanityDocumentBase>(\n  document: Doc | undefined,\n  mutation: PatchMutation,\n): MutationResult<Doc> {\n  if (!document) {\n    return {\n      status: 'error',\n      message: 'Cannot apply patch on nonexistent document',\n    }\n  }\n  const next = applyPatchMutation(mutation, document)\n  return document === next\n    ? {status: 'noop'}\n    : {status: 'updated', id: mutation.id, before: document, after: next}\n}\n","import {type Mutation, type SanityDocumentBase} from '../../mutations/types'\nimport {getMutationDocumentId} from '../utils/getMutationDocumentId'\nimport {applyDocumentMutation} from './applyDocumentMutation'\n\nexport interface UpdateResult<T extends SanityDocumentBase> {\n  id: string\n  status: 'created' | 'updated' | 'deleted'\n  before?: T\n  after?: T\n  mutations: Mutation[]\n}\n\n/**\n * Takes a list of mutations and applies them to documents in a dataset\n */\nexport function applyMutations<T extends SanityDocumentBase>(\n  mutations: Mutation[],\n  dataset: {get: (id: string) => T | undefined},\n): UpdateResult<T>[] {\n  const updatedDocs: Record<\n    string,\n    {\n      before: T | undefined\n      after: T | undefined\n      muts: Mutation[]\n    }\n  > = Object.create(null)\n\n  for (const mutation of mutations) {\n    const documentId = getMutationDocumentId(mutation)\n    if (!documentId) {\n      throw new Error('Unable to get document id from mutation')\n    }\n\n    const before = updatedDocs[documentId]?.after || dataset.get(documentId)\n    const res = applyDocumentMutation(before, mutation)\n    if (res.status === 'error') {\n      throw new Error(res.message)\n    }\n    if (res.status === 'noop') {\n      continue\n    }\n    if (\n      res.status === 'updated' ||\n      res.status === 'created' ||\n      res.status === 'deleted'\n    ) {\n      if (!(documentId in updatedDocs)) {\n        updatedDocs[documentId] = {before, after: undefined, muts: []}\n      }\n      updatedDocs[documentId]!.after = res.after\n    }\n  }\n\n  return Object.entries(updatedDocs).map(\n    // eslint-disable-next-line no-shadow\n    ([id, {before, after, muts}]) => {\n      return {\n        id,\n        status: after ? (before ? 'updated' : 'created') : 'deleted',\n        mutations: muts,\n        before,\n        after,\n      }\n    },\n  )\n}\n","import {type SanityDocumentBase} from '../../mutations/types'\nimport {type Dataset} from '../types'\nimport {type UpdateResult} from './applyMutations'\n\nexport function commit<Doc extends SanityDocumentBase>(\n  results: UpdateResult<Doc>[],\n  dataset: Dataset<Doc>,\n) {\n  results.forEach(result => {\n    if (result.status === 'created' || result.status === 'updated') {\n      dataset.set(result.id, result.after)\n    }\n    if (result.status === 'deleted') {\n      dataset.delete(result.id)\n    }\n  })\n}\n","export function takeUntil<T>(\n  arr: T[],\n  predicate: (item: T) => boolean,\n  opts?: {inclusive: boolean},\n) {\n  const result = []\n  for (const item of arr) {\n    if (predicate(item)) {\n      if (opts?.inclusive) {\n        result.push(item)\n      }\n      return result\n    }\n    result.push(item)\n  }\n  return result\n}\n\nexport function takeUntilRight<T>(\n  arr: T[],\n  predicate: (item: T) => boolean,\n  opts?: {inclusive: boolean},\n) {\n  const result = []\n  for (const item of arr.slice().reverse()) {\n    if (predicate(item)) {\n      if (opts?.inclusive) {\n        result.push(item)\n      }\n      return result\n    }\n    result.push(item)\n  }\n  return result.reverse()\n}\n","import {makePatches, stringifyPatches} from '@sanity/diff-match-patch'\n\nimport {applyNodePatch} from '../../apply'\nimport {type Operation} from '../../mutations/operations/types'\nimport {type NodePatch, type SanityDocumentBase} from '../../mutations/types'\nimport {getAtPath, type Path, startsWith, stringify} from '../../path'\nimport {takeUntilRight} from '../utils/arrayUtils'\n\nfunction isEqualPath(p1: Path, p2: Path) {\n  return stringify(p1) === stringify(p2)\n}\n\nfunction supersedes(later: Operation, earlier: Operation) {\n  return (\n    (earlier.type === 'set' || earlier.type === 'unset') &&\n    (later.type === 'set' || later.type === 'unset')\n  )\n}\n\nexport function squashNodePatches(patches: NodePatch[]) {\n  return compactSetIfMissingPatches(\n    compactSetPatches(compactUnsetPatches(patches)),\n  )\n}\n\nexport function compactUnsetPatches(patches: NodePatch[]) {\n  return patches.reduce(\n    (earlierPatches: NodePatch[], laterPatch: NodePatch) => {\n      if (laterPatch.op.type !== 'unset') {\n        earlierPatches.push(laterPatch)\n        return earlierPatches\n      }\n      // find all preceding patches that are affected by this unset\n      const unaffected = earlierPatches.filter(\n        earlierPatch => !startsWith(laterPatch.path, earlierPatch.path),\n      )\n      unaffected.push(laterPatch)\n      return unaffected\n    },\n    [],\n  )\n}\n\nexport function compactSetPatches(patches: NodePatch[]) {\n  return patches.reduceRight(\n    (laterPatches: NodePatch[], earlierPatch: NodePatch) => {\n      const replacement = laterPatches.find(\n        later =>\n          supersedes(later.op, earlierPatch.op) &&\n          isEqualPath(later.path, earlierPatch.path),\n      )\n      if (replacement) {\n        // we already have another patch later in the chain that replaces this one\n        return laterPatches\n      }\n      laterPatches.unshift(earlierPatch)\n      return laterPatches\n    },\n    [],\n  )\n}\n\nexport function compactSetIfMissingPatches(patches: NodePatch[]) {\n  return patches.reduce(\n    (previousPatches: NodePatch[], laterPatch: NodePatch) => {\n      if (laterPatch.op.type !== 'setIfMissing') {\n        previousPatches.push(laterPatch)\n        return previousPatches\n      }\n      // look at preceding patches up until the first unset\n      const check = takeUntilRight(\n        previousPatches,\n        patch => patch.op.type === 'unset',\n      )\n      const precedent = check.find(\n        precedingPatch =>\n          precedingPatch.op.type === 'setIfMissing' &&\n          isEqualPath(precedingPatch.path, laterPatch.path),\n      )\n      if (precedent) {\n        // we already have an identical patch earlier in the chain that voids this one\n        return previousPatches\n      }\n      previousPatches.push(laterPatch)\n      return previousPatches\n    },\n    [],\n  )\n}\n\nexport function compactDMPSetPatches(\n  base: SanityDocumentBase,\n  patches: NodePatch[],\n) {\n  let edge = base\n  return patches.reduce(\n    (earlierPatches: NodePatch[], laterPatch: NodePatch) => {\n      const before = edge\n      edge = applyNodePatch(laterPatch, edge)\n      if (\n        laterPatch.op.type === 'set' &&\n        typeof laterPatch.op.value === 'string'\n      ) {\n        const current = getAtPath(laterPatch.path, before)\n        if (typeof current === 'string') {\n          // we can replace the earlier diffMatchPatches with a new one\n          const replaced: NodePatch = {\n            ...laterPatch,\n            op: {\n              type: 'diffMatchPatch',\n              value: stringifyPatches(\n                makePatches(current, laterPatch.op.value),\n              ),\n            },\n          }\n          return earlierPatches\n            .flatMap(ep => {\n              return isEqualPath(ep.path, laterPatch.path) &&\n                ep.op.type === 'diffMatchPatch'\n                ? []\n                : ep\n            })\n            .concat(replaced)\n        }\n      }\n      earlierPatches.push(laterPatch)\n      return earlierPatches\n    },\n    [],\n  )\n}\n","import {\n  type Mutation,\n  type NodePatch,\n  type PatchMutation,\n  type SanityDocumentBase,\n} from '../../mutations/types'\nimport {type MutationGroup} from '../types'\nimport {compactDMPSetPatches} from './squashNodePatches'\n\nexport interface DataStore {\n  get: (id: string) => SanityDocumentBase | undefined\n}\nexport function squashDMPStrings(\n  remote: DataStore,\n  mutationGroups: MutationGroup[],\n): MutationGroup[] {\n  return mutationGroups.map(mutationGroup => ({\n    ...mutationGroup,\n    mutations: dmpIfyMutations(remote, mutationGroup.mutations),\n  }))\n}\n\nexport function dmpIfyMutations(\n  store: DataStore,\n  mutations: Mutation[],\n): Mutation[] {\n  return mutations.map((mutation, i) => {\n    return mutation.type === 'patch'\n      ? dmpifyPatchMutation(store.get(mutation.id), mutation)\n      : mutation\n  })\n}\n\nexport function dmpifyPatchMutation(\n  base: SanityDocumentBase | undefined,\n  mutation: PatchMutation,\n): PatchMutation {\n  if (!base) {\n    return mutation\n  }\n  return {\n    ...mutation,\n    patches: compactDMPSetPatches(base, mutation.patches as NodePatch[]),\n  }\n}\n","import {type MutationGroup} from '../types'\n\n/**\n * Merges adjacent non-transactional mutation groups, interleaving transactional mutations as-is\n * @param mutationGroups\n */\nexport function mergeMutationGroups(\n  mutationGroups: MutationGroup[],\n): MutationGroup[] {\n  return chunkWhile(mutationGroups, group => !group.transaction).flatMap(\n    chunk => ({\n      ...chunk[0]!,\n      mutations: chunk.flatMap(c => c.mutations),\n    }),\n  )\n}\n\n/**\n * Groups subsequent mutations into transactions, leaves transactions as-is\n * @param arr\n * @param predicate\n */\nexport function chunkWhile<T>(\n  arr: T[],\n  predicate: (item: T) => boolean,\n): T[][] {\n  const res: T[][] = []\n  let currentChunk: T[] = []\n  arr.forEach(item => {\n    if (predicate(item)) {\n      currentChunk.push(item)\n    } else {\n      if (currentChunk.length > 0) {\n        res.push(currentChunk)\n      }\n      currentChunk = []\n      res.push([item])\n    }\n  })\n  if (currentChunk.length > 0) {\n    res.push(currentChunk)\n  }\n  return res\n}\n","import {groupBy} from 'lodash'\n\nimport {type Mutation, type NodePatch} from '../../mutations/types'\nimport {type MutationGroup} from '../types'\nimport {takeUntilRight} from '../utils/arrayUtils'\nimport {getMutationDocumentId} from '../utils/getMutationDocumentId'\nimport {mergeMutationGroups} from '../utils/mergeMutationGroups'\nimport {squashNodePatches} from './squashNodePatches'\n\nexport function squashMutationGroups(staged: MutationGroup[]): MutationGroup[] {\n  return mergeMutationGroups(staged)\n    .map(transaction => ({\n      ...transaction,\n      mutations: squashMutations(transaction.mutations),\n    }))\n    .map(transaction => ({\n      ...transaction,\n      mutations: transaction.mutations.map(mutation => {\n        if (mutation.type !== 'patch') {\n          return mutation\n        }\n        return {\n          ...mutation,\n          patches: squashNodePatches(mutation.patches as NodePatch[]),\n        }\n      }),\n    }))\n}\n\ntype FIXME = Mutation[]\n\n/*\n assumptions:\n the order documents appear with their mutations within the same transaction doesn't matter\n */\nexport function squashMutations(mutations: Mutation[]): Mutation[] {\n  const byDocument = groupBy(mutations, getMutationDocumentId)\n  return Object.values(byDocument).flatMap(documentMutations => {\n    // these are the mutations that happens for the document with <id> within the same transactions\n    return squashCreateIfNotExists(squashDelete(documentMutations as FIXME))\n      .flat()\n      .reduce((acc: Mutation[], docMutation) => {\n        const prev = acc[acc.length - 1]\n        if ((!prev || prev.type === 'patch') && docMutation.type === 'patch') {\n          return acc.slice(0, -1).concat({\n            ...docMutation,\n            patches: (prev?.patches || []).concat(docMutation.patches),\n          })\n        }\n        return acc.concat(docMutation)\n      }, [])\n  })\n}\n\n/**\n * WARNING: This assumes that the mutations are only for a single document\n * @param mutations\n */\nexport function squashCreateIfNotExists(mutations: Mutation[]): Mutation[] {\n  if (mutations.length === 0) {\n    return mutations\n  }\n\n  return mutations.reduce((previousMuts: Mutation[], laterMut: Mutation) => {\n    if (laterMut.type !== 'createIfNotExists') {\n      previousMuts.push(laterMut)\n      return previousMuts\n    }\n    const prev = takeUntilRight(previousMuts, m => m.type === 'delete')\n    const precedent = prev.find(\n      precedingPatch => precedingPatch.type === 'createIfNotExists',\n    )\n    if (precedent) {\n      // we already have an identical patch earlier in the chain that voids this one\n      return previousMuts\n    }\n    previousMuts.push(laterMut)\n    return previousMuts\n  }, [])\n}\n\nfunction squashDelete(mutations: Mutation[]): Mutation[] {\n  if (mutations.length === 0) {\n    return mutations\n  }\n\n  return mutations.reduce((previousMuts: Mutation[], laterMut: Mutation) => {\n    if (laterMut.type === 'delete') {\n      return [laterMut]\n    }\n    previousMuts.push(laterMut)\n    return previousMuts\n  }, [])\n}\n","import {applyPatches} from '../apply'\nimport {\n  type Mutation,\n  type NodePatch,\n  type PatchMutation,\n  type SanityDocumentBase,\n} from '../mutations/types'\nimport {getAtPath} from '../path'\nimport {applyAll} from './datasets/applyDocumentMutation'\nimport {compactDMPSetPatches} from './optimizations/squashNodePatches'\nimport {type MutationGroup} from './types'\nimport {getMutationDocumentId} from './utils/getMutationDocumentId'\n\ntype RebaseTransaction = {\n  mutations: Mutation[]\n}\n\ntype FlatMutation = Exclude<Mutation, PatchMutation>\n\nfunction flattenMutations(mutations: Mutation[]) {\n  return mutations.flatMap((mut): Mutation | Mutation[] => {\n    if (mut.type === 'patch') {\n      return mut.patches.map(\n        (patch): PatchMutation => ({\n          type: 'patch',\n          id: mut.id,\n          patches: [patch],\n        }),\n      )\n    }\n    return mut\n  })\n}\n\nexport function rebase(\n  documentId: string,\n  oldBase: SanityDocumentBase | undefined,\n  newBase: SanityDocumentBase | undefined,\n  stagedMutations: MutationGroup[],\n): [newStage: MutationGroup[], rebased: SanityDocumentBase | undefined] {\n  // const flattened = flattenMutations(newStage.flatMap(t => t.mutations))\n\n  // 1. get the dmpified mutations from the newStage based on the old base\n  // 2. apply those to the new base\n  // 3. convert those back into set patches based on the new base and return as a new newStage\n  let edge = oldBase\n  const dmpified = stagedMutations.map(transaction => {\n    const mutations = transaction.mutations.flatMap(mut => {\n      if (getMutationDocumentId(mut) !== documentId) {\n        return []\n      }\n      const before = edge\n      edge = applyAll(edge, [mut])\n      if (!before) {\n        return mut\n      }\n      if (mut.type !== 'patch') {\n        return mut\n      }\n      return {\n        type: 'dmpified' as const,\n        mutation: {\n          ...mut,\n          // Todo: make compactDMPSetPatches return pairs of patches that was dmpified with their\n          //  original as dmpPatches and original is not 1:1 (e..g some of the original may not be dmpified)\n          dmpPatches: compactDMPSetPatches(before, mut.patches as NodePatch[]),\n          original: mut.patches,\n        },\n      }\n    })\n    return {...transaction, mutations}\n  })\n\n  let newBaseWithDMPForOldBaseApplied: SanityDocumentBase | undefined = newBase\n  // NOTE: It might not be possible to apply them - if so, we fall back to applying the pending changes\n  // todo: revisit this\n  const appliedCleanly = dmpified.map(transaction => {\n    const applied = []\n    return transaction.mutations.forEach(mut => {\n      if (mut.type === 'dmpified') {\n        // go through all dmpified, try to apply, if they fail, use the original un-optimized set patch instead\n        try {\n          newBaseWithDMPForOldBaseApplied = applyPatches(\n            mut.mutation.dmpPatches,\n            newBaseWithDMPForOldBaseApplied,\n          )\n          applied.push(mut)\n        } catch (err) {\n          // eslint-disable-next-line no-console\n          console.warn('Failed to apply dmp patch, falling back to original')\n          try {\n            newBaseWithDMPForOldBaseApplied = applyPatches(\n              mut.mutation.original,\n              newBaseWithDMPForOldBaseApplied,\n            )\n            applied.push(mut)\n          } catch (second: any) {\n            throw new Error(\n              `Failed to apply patch for document \"${documentId}\": ${second.message}`,\n            )\n          }\n        }\n      } else {\n        newBaseWithDMPForOldBaseApplied = applyAll(\n          newBaseWithDMPForOldBaseApplied,\n          [mut],\n        )\n      }\n    })\n  })\n\n  const newStage = stagedMutations.map((transaction): MutationGroup => {\n    // update all set patches to set to the current value\n    return {\n      ...transaction,\n      mutations: transaction.mutations.map(mut => {\n        if (mut.type !== 'patch' || getMutationDocumentId(mut) !== documentId) {\n          return mut\n        }\n        return {\n          ...mut,\n          patches: mut.patches.map(patch => {\n            if (patch.op.type !== 'set') {\n              return patch\n            }\n            return {\n              ...patch,\n              op: {\n                ...patch.op,\n                value: getAtPath(patch.path, newBaseWithDMPForOldBaseApplied),\n              },\n            }\n          }),\n        }\n      }),\n    }\n  })\n  return [newStage, newBaseWithDMPForOldBaseApplied]\n}\n","import type {Transaction} from '../_unstable_store'\nimport type {MutationGroup} from './types'\n\nexport function toTransactions(groups: MutationGroup[]): Transaction[] {\n  return groups.map(group => {\n    if (group.transaction && group.id !== undefined) {\n      return {id: group.id!, mutations: group.mutations}\n    }\n    return {mutations: group.mutations}\n  })\n}\n","import {\n  type Mutation,\n  type NodePatch,\n  type Transaction,\n} from '../../mutations/types'\nimport {stringify as stringifyPath} from '../../path/parser/stringify'\n\nexport function encode(mutation: Mutation) {\n  return encodeMutation(mutation)\n}\n\nexport function encodeAll(mutations: Mutation[]) {\n  return mutations.flatMap(encode)\n}\n\nexport function encodeTransaction(transaction: Transaction) {\n  return {\n    transactionId: transaction.id,\n    mutations: encodeAll(transaction.mutations),\n  }\n}\n\nexport function encodeMutation(mutation: Mutation) {\n  if (\n    mutation.type === 'create' ||\n    mutation.type === 'createIfNotExists' ||\n    mutation.type === 'createOrReplace'\n  ) {\n    return {[mutation.type]: mutation.document}\n  }\n  if (mutation.type === 'delete') {\n    return {\n      delete: {id: mutation.id},\n    }\n  }\n  const ifRevisionID = mutation.options?.ifRevision\n  return mutation.patches.map(patch => {\n    return {\n      patch: {\n        id: mutation.id,\n        ...(ifRevisionID && {ifRevisionID}),\n        ...patchToSanity(patch),\n      },\n    }\n  })\n}\n\nfunction patchToSanity(patch: NodePatch) {\n  const {path, op} = patch\n  if (op.type === 'unset') {\n    return {unset: [stringifyPath(path)]}\n  }\n  if (op.type === 'insert') {\n    return {\n      insert: {\n        [op.position]: stringifyPath([...path, op.referenceItem]),\n        items: op.items,\n      },\n    }\n  }\n  if (op.type === 'diffMatchPatch') {\n    return {diffMatchPatch: {[stringifyPath(path)]: op.value}}\n  }\n  if (op.type === 'inc') {\n    return {inc: {[stringifyPath(path)]: op.amount}}\n  }\n  if (op.type === 'dec') {\n    return {dec: {[stringifyPath(path)]: op.amount}}\n  }\n  if (op.type === 'set' || op.type === 'setIfMissing') {\n    return {[op.type]: {[stringifyPath(path)]: op.value}}\n  }\n  if (op.type === 'truncate') {\n    const range = [\n      op.startIndex,\n      typeof op.endIndex === 'number' ? op.endIndex : '',\n    ].join(':')\n\n    return {unset: [`${stringifyPath(path)}[${range}]`]}\n  }\n  if (op.type === 'upsert') {\n    // note: upsert currently not supported by sanity, so will always insert at reference position\n    return {\n      unset: op.items.map(item =>\n        stringifyPath([...path, {_key: (item as any)._key}]),\n      ),\n      insert: {\n        [op.position]: stringifyPath([...path, op.referenceItem]),\n        items: op.items,\n      },\n    }\n  }\n  if (op.type === 'assign') {\n    return {\n      set: Object.fromEntries(\n        Object.keys(op.value).map(key => [\n          stringifyPath(path.concat(key)),\n          op.value[key as keyof typeof op.value],\n        ]),\n      ),\n    }\n  }\n  if (op.type === 'unassign') {\n    return {\n      unset: op.keys.map(key => stringifyPath(path.concat(key))),\n    }\n  }\n  if (op.type === 'replace') {\n    return {\n      insert: {\n        replace: stringifyPath(path.concat(op.referenceItem)),\n        items: op.items,\n      },\n    }\n  }\n  if (op.type === 'remove') {\n    return {\n      unset: [stringifyPath(path.concat(op.referenceItem))],\n    }\n  }\n  //@ts-expect-error all cases should be covered\n  throw new Error(`Unknown operation type ${op.type}`)\n}\n","import {\n  type MutationEvent,\n  type ReconnectEvent,\n  type SanityClient,\n  type WelcomeEvent,\n} from '@sanity/client'\nimport {filter, merge, type ObservedValueOf, share, shareReplay} from 'rxjs'\n\n/**\n * Creates a single, shared, listener EventSource that strems remote mutations, and notifies when it's online (welcome), offline (reconnect).\n */\nexport function createSharedListener(client: SanityClient) {\n  const allEvents$ = client\n    .listen(\n      '*[!(_id in path(\"_.**\"))]',\n      {},\n      {\n        events: ['welcome', 'mutation', 'reconnect'],\n        includeResult: false,\n        includePreviousRevision: false,\n        visibility: 'transaction',\n        effectFormat: 'mendoza',\n        includeMutations: false,\n      },\n    )\n    .pipe(share({resetOnRefCountZero: true}))\n\n  // Reconnect events emitted in case the connection is lost\n  const reconnect = allEvents$.pipe(\n    filter((event): event is ReconnectEvent => event.type === 'reconnect'),\n  )\n\n  // Welcome events are emitted when the listener is (re)connected\n  const welcome = allEvents$.pipe(\n    filter((event): event is WelcomeEvent => event.type === 'welcome'),\n  )\n\n  // Mutation events coming from the listener\n  const mutations = allEvents$.pipe(\n    filter((event): event is MutationEvent => event.type === 'mutation'),\n  )\n\n  // Replay the latest connection event that was emitted either when the connection was disconnected ('reconnect'), established or re-established ('welcome')\n  const connectionEvent = merge(welcome, reconnect).pipe(\n    shareReplay({bufferSize: 1, refCount: true}),\n  )\n\n  // Emit the welcome event if the latest connection event was the 'welcome' event.\n  // Downstream subscribers will typically map the welcome event to an initial fetch\n  const replayWelcome = connectionEvent.pipe(\n    filter(latestConnectionEvent => latestConnectionEvent.type === 'welcome'),\n  )\n\n  // Combine into a single stream\n  return merge(replayWelcome, mutations, reconnect)\n}\n\nexport type SharedListenerEvents = ObservedValueOf<\n  ReturnType<typeof createSharedListener>\n>\n","import {\n  type MutationEvent,\n  type SanityClient,\n  type SanityDocument,\n} from '@sanity/client'\nimport {applyPatch, type RawPatch} from 'mendoza'\nimport {asapScheduler, defer, filter, observeOn} from 'rxjs'\nimport {\n  assertEvent,\n  assign,\n  enqueueActions,\n  fromEventObservable,\n  fromPromise,\n  raise,\n  sendParent,\n  setup,\n  spawnChild,\n  stopChild,\n} from 'xstate'\n\nimport {encodeTransaction, type Mutation} from '../encoders/sanity'\nimport {\n  type MutationGroup,\n  type SanityDocumentBase,\n  type Transaction,\n} from '../store'\nimport {applyMutations} from '../store/datasets/applyMutations'\nimport {commit} from '../store/datasets/commit'\nimport {squashDMPStrings} from '../store/optimizations/squashDMPStrings'\nimport {squashMutationGroups} from '../store/optimizations/squashMutations'\nimport {rebase} from '../store/rebase'\nimport {toTransactions} from '../store/toTransactions'\nimport {createSharedListener, type SharedListenerEvents} from './listener'\n\nexport interface DocumentMutatorMachineInput {\n  id: string\n  client: SanityClient\n  /** A shared listener can be provided, if not it'll be created using `client.listen()` */\n  sharedListener?: ReturnType<typeof createSharedListener>\n  /* Preferrably a LRU cache map that is compatible with an ES6 Map, and have documents that allow unique ids to a particular dataset */\n  cache?: Map<string, SanityDocument<DocumentType> | null>\n}\n\nexport type DocumentMutatorMachineParentEvent =\n  | {type: 'sync'; id: string; document: SanityDocumentBase}\n  | {\n      type: 'mutation'\n      id: string\n      effects: {apply: RawPatch}\n      previousRev: string\n      resultRev: string\n    }\n  | {type: 'rebased.local'; id: string; document: SanityDocumentBase}\n  | {type: 'rebased.remote'; id: string; document: SanityDocumentBase}\n  | {type: 'pristine'; id: string}\n\nexport const documentMutatorMachine = setup({\n  types: {} as {\n    children: {\n      getDocument: 'fetch remote snapshot'\n      submitTransactions: 'submit mutations as transactions'\n    }\n    tags: 'busy' | 'error' | 'ready'\n    context: {\n      client: SanityClient\n      /** A shared listener can be provided, if not it'll be created using `client.listen()` */\n      sharedListener?: ReturnType<typeof createSharedListener>\n      /** The document id */\n      id: string\n      /* Preferrably a LRU cache map that is compatible with an ES6 Map, and have documents that allow unique ids to a particular dataset */\n      cache?: Map<string, SanityDocument<DocumentType> | null>\n      /* The remote snapshot of what the document looks like in Content Lake, kept in sync by applying Mendoza patches in real time. undefined means it's unknown if it exists yet, null means its known that it doesn't exist. */\n      remote: SanityDocument<DocumentType> | null | undefined\n      /* Local snapshot, that is rebased to the remote snapshot whenever that snapshot changes, and allows optimistic local mutations. undefined means it's unknown if the document exists in content lake yet, if both `remote` and `local` is `null` it means it's known that it doesn't exist. If `remote` is defined, and `local` is `null` it means it's optimistically deleted. If `remote` is `null` and `local` defined then it's optimistically created. */\n      local: SanityDocument<DocumentType> | null | undefined\n      /* Remote mendoza mutation events, needs a better name to differentiate from optimistic mutations */\n      mutationEvents: MutationEvent[]\n      /* Track staged mutations that can be submitted */\n      stagedChanges: MutationGroup[]\n      /* Queue mutations mutations that should be staged after an ongoing submission settles */\n      stashedChanges: MutationGroup[]\n      /* Any kind of error object that the UI can parse and decide how to display/report */\n      error: unknown\n      /* Used for automatic retrying of loading the remote snapshot */\n      fetchRemoteSnapshotAttempts: number\n      /* Used for automatic retrying of submitting mutations to Content Lake as a transaction */\n      submitTransactionsAttempts: number\n    }\n    events:\n      | SharedListenerEvents\n      | {type: 'error'}\n      | {type: 'retry'}\n      | {type: 'connect'}\n      | {type: 'reconnect'}\n      | {type: 'welcome'}\n      | {type: 'mutate'; mutations: Mutation[]}\n      | {type: 'submit'}\n      | {\n          type: 'xstate.done.actor.getDocument'\n          output: SanityDocument<DocumentType>\n        }\n      | {\n          type: 'xstate.done.actor.submitTransactions'\n          output: undefined\n        }\n    input: DocumentMutatorMachineInput\n  },\n  actions: {\n    'assign error to context': assign({error: ({event}) => event}),\n    'clear error from context': assign({error: undefined}),\n    'connect to server-sent events': raise({type: 'connect'}),\n    'listen to server-sent events': spawnChild('server-sent events', {\n      id: 'listener',\n      input: ({context}) => ({\n        listener:\n          context.sharedListener || createSharedListener(context.client),\n        id: context.id,\n      }),\n    }),\n    'stop listening to server-sent events': stopChild('listener'),\n    'buffer remote mutation events': assign({\n      mutationEvents: ({event, context}) => {\n        assertEvent(event, 'mutation')\n        return [...context.mutationEvents, event]\n      },\n    }),\n    'restore stashed changes': assign({\n      stagedChanges: ({event, context}) => {\n        assertEvent(event, 'xstate.done.actor.submitTransactions')\n        return context.stashedChanges\n      },\n      stashedChanges: [],\n    }),\n    'rebase fetched remote snapshot': enqueueActions(({enqueue}) => {\n      enqueue.assign(({event, context}) => {\n        assertEvent(event, 'xstate.done.actor.getDocument')\n        const previousRemote = context.remote\n        let nextRemote = event.output\n\n        /**\n         * We assume all patches that happen while we're waiting for the document to resolve are already applied.\n         * But if we do see a patch that has the same revision as the document we just fetched, we should apply any patches following it\n         */\n        let seenCurrentRev = false\n        for (const patch of context.mutationEvents) {\n          if (\n            !patch.effects?.apply ||\n            (!patch.previousRev && patch.transition !== 'appear')\n          )\n            continue\n          if (!seenCurrentRev && patch.previousRev === nextRemote?._rev) {\n            seenCurrentRev = true\n          }\n          if (seenCurrentRev) {\n            nextRemote = applyMendozaPatch(\n              nextRemote,\n              patch.effects.apply,\n              patch.resultRev,\n            )\n          }\n        }\n\n        if (\n          context.cache &&\n          // If the shared cache don't have the document already we can just set it\n          (!context.cache.has(context.id) ||\n            // But when it's in the cache, make sure it's necessary to update it\n            context.cache.get(context.id)!._rev !== nextRemote?._rev)\n        ) {\n          context.cache.set(context.id, nextRemote as unknown as any)\n        }\n\n        const [stagedChanges, local] = rebase(\n          context.id,\n          // It's annoying to convert between null and undefined, reach consensus\n          previousRemote === null ? undefined : previousRemote,\n          nextRemote === null ? undefined : (nextRemote as unknown as any),\n          context.stagedChanges,\n        )\n\n        return {\n          remote: nextRemote as unknown as any,\n          local: local as unknown as any,\n          stagedChanges,\n          // Since the snapshot handler applies all the patches they are no longer needed, allow GC\n          mutationEvents: [],\n        }\n      })\n      enqueue.sendParent(\n        ({context}) =>\n          ({\n            type: 'rebased.remote',\n            id: context.id,\n            document: context.remote!,\n          }) satisfies DocumentMutatorMachineParentEvent,\n      )\n    }),\n    'apply mendoza patch': assign(({event, context}) => {\n      assertEvent(event, 'mutation')\n      const previousRemote = context.remote\n      // We have already seen this mutation\n      if (event.transactionId === previousRemote?._rev) {\n        return {}\n      }\n\n      const nextRemote = applyMendozaPatch(\n        previousRemote!,\n        event.effects!.apply,\n        event.resultRev,\n      )\n\n      if (\n        context.cache &&\n        // If the shared cache don't have the document already we can just set it\n        (!context.cache.has(context.id) ||\n          // But when it's in the cache, make sure it's necessary to update it\n          context.cache.get(context.id)!._rev !== nextRemote?._rev)\n      ) {\n        context.cache.set(context.id, nextRemote as unknown as any)\n      }\n\n      const [stagedChanges, local] = rebase(\n        context.id,\n        // It's annoying to convert between null and undefined, reach consensus\n        previousRemote === null ? undefined : previousRemote,\n        nextRemote === null ? undefined : (nextRemote as unknown as any),\n        context.stagedChanges,\n      )\n\n      return {\n        remote: nextRemote as unknown as any,\n        local: local as unknown as any,\n        stagedChanges,\n      }\n    }),\n    'increment fetch attempts': assign({\n      fetchRemoteSnapshotAttempts: ({context}) =>\n        context.fetchRemoteSnapshotAttempts + 1,\n    }),\n    'reset fetch attempts': assign({\n      fetchRemoteSnapshotAttempts: 0,\n    }),\n    'increment submit attempts': assign({\n      submitTransactionsAttempts: ({context}) =>\n        context.submitTransactionsAttempts + 1,\n    }),\n    'reset submit attempts': assign({\n      submitTransactionsAttempts: 0,\n    }),\n    'stage mutation': assign({\n      stagedChanges: ({event, context}) => {\n        assertEvent(event, 'mutate')\n        return [\n          ...context.stagedChanges,\n          {transaction: false, mutations: event.mutations},\n        ]\n      },\n    }),\n    'stash mutation': assign({\n      stashedChanges: ({event, context}) => {\n        assertEvent(event, 'mutate')\n        return [\n          ...context.stashedChanges,\n          {transaction: false, mutations: event.mutations},\n        ]\n      },\n    }),\n    'rebase local snapshot': enqueueActions(({enqueue}) => {\n      enqueue.assign({\n        local: ({event, context}) => {\n          assertEvent(event, 'mutate')\n          // @TODO would be helpful to not have to convert back and forth between maps\n          const localDataset = new Map()\n          if (context.local) {\n            localDataset.set(context.id, context.local)\n          }\n          // Apply mutations to local dataset (note: this is immutable, and doesn't change the dataset)\n          const results = applyMutations(event.mutations, localDataset)\n          // Write the updated results back to the \"local\" dataset\n          commit(results, localDataset)\n          // Read the result from the local dataset again\n          return localDataset.get(context.id)\n        },\n      })\n      enqueue.sendParent(\n        ({context}) =>\n          ({\n            type: 'rebased.local',\n            id: context.id,\n            document: context.local!,\n          }) satisfies DocumentMutatorMachineParentEvent,\n      )\n    }),\n    'send pristine event to parent': sendParent(\n      ({context}) =>\n        ({\n          type: 'pristine',\n          id: context.id,\n        }) satisfies DocumentMutatorMachineParentEvent,\n    ),\n    'send sync event to parent': sendParent(\n      ({context}) =>\n        ({\n          type: 'sync',\n          id: context.id,\n          document: context.remote!,\n        }) satisfies DocumentMutatorMachineParentEvent,\n    ),\n    'send mutation event to parent': sendParent(({context, event}) => {\n      assertEvent(event, 'mutation')\n      return {\n        type: 'mutation',\n        id: context.id,\n        previousRev: event.previousRev!,\n        resultRev: event.resultRev!,\n        effects: event.effects!,\n      } satisfies DocumentMutatorMachineParentEvent\n    }),\n  },\n  actors: {\n    'server-sent events': fromEventObservable(\n      ({\n        input,\n      }: {\n        input: {listener: ReturnType<typeof createSharedListener>; id: string}\n      }) => {\n        const {listener, id} = input\n        return defer(() => listener).pipe(\n          filter(\n            event =>\n              event.type === 'welcome' ||\n              event.type === 'reconnect' ||\n              (event.type === 'mutation' && event.documentId === id),\n          ),\n          // This is necessary to avoid sync emitted events from `shareReplay` from happening before the actor is ready to receive them\n          observeOn(asapScheduler),\n        )\n      },\n    ),\n    'fetch remote snapshot': fromPromise(\n      async ({\n        input,\n        signal,\n      }: {\n        input: {client: SanityClient; id: string}\n        signal: AbortSignal\n      }) => {\n        const {client, id} = input\n        const document = await client\n          .getDocument(id, {\n            signal,\n          })\n          .catch(e => {\n            if (e instanceof Error && e.name === 'AbortError') return\n            throw e\n          })\n\n        return document\n      },\n    ),\n    'submit mutations as transactions': fromPromise(\n      async ({\n        input,\n        signal,\n      }: {\n        input: {client: SanityClient; transactions: Transaction[]}\n        signal: AbortSignal\n      }) => {\n        const {client, transactions} = input\n        for (const transaction of transactions) {\n          if (signal.aborted) return\n          await client\n            .dataRequest('mutate', encodeTransaction(transaction), {\n              visibility: 'async',\n              returnDocuments: false,\n              signal,\n            })\n            .catch(e => {\n              if (e instanceof Error && e.name === 'AbortError') return\n              throw e\n            })\n        }\n      },\n    ),\n  },\n  delays: {\n    // Exponential backoff delay function\n    fetchRemoteSnapshotTimeout: ({context}) =>\n      Math.pow(2, context.fetchRemoteSnapshotAttempts) * 1000,\n    submitTransactionsTimeout: ({context}) =>\n      Math.pow(2, context.submitTransactionsAttempts) * 1000,\n  },\n}).createMachine({\n  /** @xstate-layout N4IgpgJg5mDOIC5QQPYGMCuBbMA7ALgLRYb4CG+KATgMQnn5gDaADALqKgAOKsAlvj4pcnEAA9EADhYAWAHQA2GSwUBmAKwBOaQEZJkhQBoQAT0Q6ATAF8rx1JhwFipCtTkQ+sNMNxg0jCBpvXF9-Vg4kEB5+QWFRCQQLFhY5PQB2dRU1SQsdGSVjMwRlHTkWNM00nR1VKryKmzt0bDwielcqOWDQwVwoGgB3MAAbbxxw0WiBIRFIhPUKuQ1NVU0tTU0WFdVCxAt1dTlNhX2WdRltGUk061sQexandspO7r9e-qo-H3eJyKnYrNQPNJJollpVutNttdghVCo5MoTgoMpo8jIkqpGvdmo42i4Xl0fv4+H0aGAqFRqH9uLxpnE5ogFrCLFd5CtNBYFJkdOpuaosXcHnjnAw3G9-AAxMh8YYYL5BYn4GlROmA+KIFEs1R6ORpZYWHIXGR6bHC1qijpyL4Sj6DEZjZjsSZqmYaxK1ORcvlc-ZqSoyNKwnRpGTyK4WDK5BQ6BQ5BRm3EW55uG1K0n9ClUqgqgFuxketJe7nIv2rUNB0x7LmSL2qGMsSySevcmSJhzJgnipWQOgEma510M4HmcqHZYyWqaOMqTQyWGh0osVSGiwC5uGyftx74sWvHuBNMhX7O-5DoHiPae72lvnlwPBydFlRVS7qPIl7cilP74-+SByMMKBkB4ZKoL4cikgAbigADWYByDA+AACJJgQg4xPmI7FHkZQrKGsjqKcCiaMG9YpJOxySBiCiyPoX6dnuRJ-gEgHAaBmaUm4XDDBQABm1BYIhYAoWhyqnrSmHDpeCAKCicjUbU6g6nkFichYsJrLWVxaPsk7KdICZCmJlqEraAFASBvbPAOEmqlJF4JJURbVDcy4Yvk1GVkUsabApMjKZGqjNg2kgMU8Xa-j0FnsQBXBUJ4vRgH2DBOhEkn0o5TLKV6y6WDG6lhkYVYIDoKzyBkeR8pUDZqOFu5WuZEBsVZzUeFQ+AmDQsAYAARlgAgYZl7o6I2tYLJINSSO+3JaMGlQpGkhFhryo2jW2xkdhFTFNS1EAAT1-UCHa4EIdBcEIYdA34AAKlQZC4LAZAksIsBDeqBbrdpym8iuByxlcLK5BYqQLBUZyTcFvL1aZ3YsTFrVyFdx0ZuSXGdDx-GCUjfXXXdD1PS9j3vVhMnrWCFRxtNaRLdcfIsiwuS5fkgZaOUlhpDDP7MdFzWWftzXI-gdrPGlLoOSNyiHFstRySisjcgzahyFoUYBbRsac5tO6w1F7wIwLONHfg0qyvKyVfPgVAmCT0kJGt41pJD02xgcpElUkcZ6rI+q5JcckbU0W0NWZB57QduMCKbcoKmIsCpXIZB8YwVAABRC-jj3PYCsA3XwOAoKQACUNDmttjVh-zEfG9H5u21lpVjSrTtTTNbsstUYJJAFWgA37XORTz+t8+xtcKpb1v1+6KJFopGQqRi6nBlstYcqNK5riusYDztlejzKMfJXHCdJynqd8SJaAABYAEpgFgKCMAAyrgZBcLAV+P3nBfF6XJnc7tfmY8xZnglgWGe-klILzUhYDSJVRpnCONNOcWxWRKBRDYO4uAUD7XgJEMuIdqDi2GgWQgOhgxMyRKyFc8IuQkXUDvK0HgvAHmIR9bCD4SoeSWCoLkoZpxrmXIw0OLEMxsNJgkSc418KhnrHyG4oZYTcPhMifhJx4SCiDjrABSpgHiLtogAUhwW77DRIGXkk55wexKCrJQsg1jBTnPsYRqZviiL6PohuORgyhhBhGKMsZYzxhcXrf8EBPHulUJOPCtRlABWIu7IoORVBIIhMpNYGJyghKHmEvaYjQEkOwhkxQrJtBES0JDOBPlkgKD1JYZSjZORyTXNkwBsVwkFPYTJVYS58JxPKbOYM0gUj7FjGcEMOpciaJxMHXWOTWJV2avFRKpIwARILJRGJBF4mZBIkDE0KtIxLSSDkDYGhWl70Ru1Tq6zsLURBkoLyWRmz8PmlUZmcY1zXDKdMghcy2mIyFh8W5ZN4RFmOFyKaZwiLeT2GVJcy5pBrguCiMK2tvyDwBYbIWejOkSMQBkeQORJq0RNCUDIDNondxuGpPQmRqIXPhiPECuKMpdMkbILZ-SEnLxyjqOJMZsj1jRTYIAA */\n\n  id: 'document-mutator',\n\n  context: ({input}) => ({\n    client: input.client.withConfig({allowReconfigure: false}),\n    sharedListener: input.sharedListener,\n    id: input.id,\n    remote: undefined,\n    local: undefined,\n    mutationEvents: [],\n    stagedChanges: [],\n    stashedChanges: [],\n    error: undefined,\n    fetchRemoteSnapshotAttempts: 0,\n    submitTransactionsAttempts: 0,\n    cache: input.cache,\n  }),\n\n  // Auto start the connection by default\n  entry: ['connect to server-sent events'],\n\n  on: {\n    mutate: {\n      actions: ['rebase local snapshot', 'stage mutation'],\n    },\n  },\n  initial: 'disconnected',\n  states: {\n    disconnected: {\n      on: {\n        connect: {\n          target: 'connecting',\n          actions: ['listen to server-sent events'],\n        },\n      },\n    },\n    connecting: {\n      on: {\n        welcome: 'connected',\n        reconnect: 'reconnecting',\n        error: 'connectFailure',\n      },\n      tags: ['busy'],\n    },\n    connectFailure: {\n      on: {\n        connect: {\n          target: 'connecting',\n          actions: ['listen to server-sent events'],\n        },\n      },\n      entry: [\n        'stop listening to server-sent events',\n        'assign error to context',\n      ],\n      exit: ['clear error from context'],\n      tags: ['error'],\n    },\n    reconnecting: {\n      on: {\n        welcome: {\n          target: 'connected',\n        },\n        error: {\n          target: 'connectFailure',\n        },\n      },\n      tags: ['busy', 'error'],\n    },\n    connected: {\n      on: {\n        mutation: {\n          actions: ['buffer remote mutation events'],\n        },\n        reconnect: 'reconnecting',\n      },\n      entry: ['clear error from context'],\n      initial: 'loading',\n      states: {\n        loading: {\n          invoke: {\n            src: 'fetch remote snapshot',\n            id: 'getDocument',\n            input: ({context}) => ({\n              client: context.client,\n              id: context.id,\n            }),\n            onError: {\n              target: 'loadFailure',\n            },\n            onDone: {\n              target: 'loaded',\n              actions: [\n                'rebase fetched remote snapshot',\n                'reset fetch attempts',\n              ],\n            },\n          },\n\n          tags: ['busy'],\n        },\n\n        loaded: {\n          entry: ['send sync event to parent'],\n          on: {\n            mutation: {\n              actions: ['apply mendoza patch', 'send mutation event to parent'],\n            },\n          },\n          initial: 'pristine',\n\n          states: {\n            pristine: {\n              on: {\n                mutate: {\n                  actions: ['rebase local snapshot', 'stage mutation'],\n                  target: 'dirty',\n                },\n              },\n              tags: ['ready'],\n            },\n            dirty: {\n              on: {\n                submit: 'submitting',\n              },\n              tags: ['ready'],\n            },\n            submitting: {\n              on: {\n                mutate: {\n                  actions: ['rebase local snapshot', 'stash mutation'],\n                },\n              },\n              invoke: {\n                src: 'submit mutations as transactions',\n                id: 'submitTransactions',\n                input: ({context}) => {\n                  // @TODO perhaps separate utils to be lower level and operate on single documents at a time instead of expecting a local dataset\n                  const remoteDataset = new Map()\n                  remoteDataset.set(context.id, context.remote)\n                  return {\n                    client: context.client,\n                    transactions: toTransactions(\n                      // Squashing DMP strings is the last thing we do before submitting\n                      squashDMPStrings(\n                        remoteDataset,\n                        squashMutationGroups(context.stagedChanges),\n                      ),\n                    ),\n                  }\n                },\n                onError: {\n                  target: 'submitFailure',\n                },\n\n                onDone: {\n                  target: 'pristine',\n                  actions: [\n                    'restore stashed changes',\n                    'reset submit attempts',\n                    'send pristine event to parent',\n                  ],\n                },\n              },\n              /**\n               * 'busy' means we should show a spinner, 'ready' means we can still accept mutations, they'll be applied optimistically right away, and queued for submissions after the current submission settles\n               */\n              tags: ['busy', 'ready'],\n            },\n            submitFailure: {\n              exit: ['clear error from context'],\n              after: {\n                submitTransactionsTimeout: {\n                  actions: ['increment submit attempts'],\n                  target: 'submitting',\n                },\n              },\n              on: {\n                retry: 'submitting',\n              },\n              /**\n               * How can it be both `ready` and `error`? `ready` means it can receive mutations, optimistically apply them, and queue them for submission. `error` means it failed to submit previously applied mutations.\n               * It's completely fine to keep queueing up more mutations and applying them optimistically, while showing UI that notifies that mutations didn't submit, and show a count down until the next automatic retry.\n               */\n              tags: ['error', 'ready'],\n            },\n          },\n        },\n\n        loadFailure: {\n          exit: ['clear error from context'],\n          after: {\n            fetchRemoteSnapshotTimeout: {\n              actions: ['increment fetch attempts'],\n              target: 'loading',\n            },\n          },\n          on: {\n            retry: 'loading',\n          },\n          tags: ['error'],\n        },\n      },\n    },\n  },\n})\n\nfunction applyMendozaPatch<const DocumentType extends SanityDocumentBase>(\n  document: DocumentType | undefined,\n  patch: RawPatch,\n  nextRevision: string | undefined,\n) {\n  const next = applyPatch(omitRev(document), patch)\n  if (!next) {\n    return null\n  }\n  return Object.assign(next, {_rev: nextRevision})\n}\n\nfunction omitRev<const DocumentType extends SanityDocumentBase>(\n  document: DocumentType | undefined,\n) {\n  if (!document) {\n    return null\n  }\n  // eslint-disable-next-line unused-imports/no-unused-vars\n  const {_rev, ...doc} = document\n  return doc\n}\n"],"names":["scopedUrlAlphabet","applyPatches","patch","stringifyPath","assign"],"mappings":"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","debugId":null}}]
}